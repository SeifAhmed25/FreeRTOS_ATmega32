
RTOS_APP.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001794  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000034  00800060  00001794  00001828  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004dd  00800094  00800094  0000185c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000185c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000188c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000004b0  00000000  00000000  000018c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004744  00000000  00000000  00001d78  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001288  00000000  00000000  000064bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002a3c  00000000  00000000  00007744  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000c88  00000000  00000000  0000a180  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000144e  00000000  00000000  0000ae08  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003c99  00000000  00000000  0000c256  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000448  00000000  00000000  0000feef  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 aa 03 	jmp	0x754	; 0x754 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e9       	ldi	r30, 0x94	; 148
      68:	f7 e1       	ldi	r31, 0x17	; 23
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a4 39       	cpi	r26, 0x94	; 148
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	25 e0       	ldi	r18, 0x05	; 5
      78:	a4 e9       	ldi	r26, 0x94	; 148
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a1 37       	cpi	r26, 0x71	; 113
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 65 0b 	call	0x16ca	; 0x16ca <main>
      8a:	0c 94 c8 0b 	jmp	0x1790	; 0x1790 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Leds_Off>:
void Leds_AllInit(void){
	Leds_Init(LEDS_MSK);
	Leds_AllOff();
}
void Leds_AllOn(void){
	Leds_On(LEDS_MSK);
      92:	9b b3       	in	r25, 0x1b	; 27
      94:	80 95       	com	r24
      96:	98 23       	and	r25, r24
      98:	9b bb       	out	0x1b, r25	; 27
      9a:	08 95       	ret

0000009c <Leds_Init>:
      9c:	9a b3       	in	r25, 0x1a	; 26
      9e:	98 2b       	or	r25, r24
      a0:	9a bb       	out	0x1a, r25	; 26
      a2:	0e 94 49 00 	call	0x92	; 0x92 <Leds_Off>
      a6:	08 95       	ret

000000a8 <Leds_AllOff>:
}
void Leds_AllOff(void){
	Leds_Off(LEDS_MSK);
      a8:	80 e7       	ldi	r24, 0x70	; 112
      aa:	0e 94 49 00 	call	0x92	; 0x92 <Leds_Off>
      ae:	08 95       	ret

000000b0 <Leds_AllInit>:
	toggleBits(LEDS_PORT,ledMask);
}

/* All leds */
void Leds_AllInit(void){
	Leds_Init(LEDS_MSK);
      b0:	80 e7       	ldi	r24, 0x70	; 112
      b2:	0e 94 4e 00 	call	0x9c	; 0x9c <Leds_Init>
	Leds_AllOff();
      b6:	0e 94 54 00 	call	0xa8	; 0xa8 <Leds_AllOff>
      ba:	08 95       	ret

000000bc <Key_Init>:
};

/* Routines */
void	Key_Init(void){
	/* Rows */
	setBits(KEY_ROW_DDR, KEY_ROWS_MSK);		/* Out */
      bc:	84 b3       	in	r24, 0x14	; 20
      be:	8c 61       	ori	r24, 0x1C	; 28
      c0:	84 bb       	out	0x14, r24	; 20
	setBits(KEY_ROW_PORT, KEY_ROWS_MSK);	/* High Default */
      c2:	85 b3       	in	r24, 0x15	; 21
      c4:	8c 61       	ori	r24, 0x1C	; 28
      c6:	85 bb       	out	0x15, r24	; 21
	/* Cols */
	clearBits(KEY_COL_DDR, KEY_COLS_MSK);	/* In */
      c8:	81 b3       	in	r24, 0x11	; 17
      ca:	8f 71       	andi	r24, 0x1F	; 31
      cc:	81 bb       	out	0x11, r24	; 17
	setBits(KEY_COL_PORT, KEY_COLS_MSK);	/* Pullup */
      ce:	82 b3       	in	r24, 0x12	; 18
      d0:	80 6e       	ori	r24, 0xE0	; 224
      d2:	82 bb       	out	0x12, r24	; 18
      d4:	08 95       	ret

000000d6 <LCD_Latch>:
	LCD_SendData(data);
}
void LCD_DispCharXY(u8 row, u8 col, u8 data){
	LCD_GotoXY(row,col);
	LCD_DispChar(data);
}
      d6:	8b b3       	in	r24, 0x1b	; 27
      d8:	84 60       	ori	r24, 0x04	; 4
      da:	8b bb       	out	0x1b, r24	; 27
      dc:	85 e0       	ldi	r24, 0x05	; 5
      de:	8a 95       	dec	r24
      e0:	f1 f7       	brne	.-4      	; 0xde <LCD_Latch+0x8>
      e2:	00 00       	nop
      e4:	8b b3       	in	r24, 0x1b	; 27
      e6:	8b 7f       	andi	r24, 0xFB	; 251
      e8:	8b bb       	out	0x1b, r24	; 27
      ea:	08 95       	ret

000000ec <LCD_SendCMD>:
      ec:	cf 93       	push	r28
      ee:	c8 2f       	mov	r28, r24
      f0:	8b b3       	in	r24, 0x1b	; 27
      f2:	87 7f       	andi	r24, 0xF7	; 247
      f4:	8b bb       	out	0x1b, r24	; 27
      f6:	88 b3       	in	r24, 0x18	; 24
      f8:	88 7f       	andi	r24, 0xF8	; 248
      fa:	88 bb       	out	0x18, r24	; 24
      fc:	98 b3       	in	r25, 0x18	; 24
      fe:	8c 2f       	mov	r24, r28
     100:	82 95       	swap	r24
     102:	8f 70       	andi	r24, 0x0F	; 15
     104:	28 2f       	mov	r18, r24
     106:	27 70       	andi	r18, 0x07	; 7
     108:	92 2b       	or	r25, r18
     10a:	98 bb       	out	0x18, r25	; 24
     10c:	98 b3       	in	r25, 0x18	; 24
     10e:	9f 7e       	andi	r25, 0xEF	; 239
     110:	98 bb       	out	0x18, r25	; 24
     112:	28 b3       	in	r18, 0x18	; 24
     114:	90 e0       	ldi	r25, 0x00	; 0
     116:	88 0f       	add	r24, r24
     118:	99 1f       	adc	r25, r25
     11a:	80 71       	andi	r24, 0x10	; 16
     11c:	82 2b       	or	r24, r18
     11e:	88 bb       	out	0x18, r24	; 24
     120:	0e 94 6b 00 	call	0xd6	; 0xd6 <LCD_Latch>
     124:	88 b3       	in	r24, 0x18	; 24
     126:	88 7f       	andi	r24, 0xF8	; 248
     128:	88 bb       	out	0x18, r24	; 24
     12a:	88 b3       	in	r24, 0x18	; 24
     12c:	9c 2f       	mov	r25, r28
     12e:	97 70       	andi	r25, 0x07	; 7
     130:	89 2b       	or	r24, r25
     132:	88 bb       	out	0x18, r24	; 24
     134:	88 b3       	in	r24, 0x18	; 24
     136:	8f 7e       	andi	r24, 0xEF	; 239
     138:	88 bb       	out	0x18, r24	; 24
     13a:	28 b3       	in	r18, 0x18	; 24
     13c:	8c 2f       	mov	r24, r28
     13e:	90 e0       	ldi	r25, 0x00	; 0
     140:	88 0f       	add	r24, r24
     142:	99 1f       	adc	r25, r25
     144:	80 71       	andi	r24, 0x10	; 16
     146:	82 2b       	or	r24, r18
     148:	88 bb       	out	0x18, r24	; 24
     14a:	0e 94 6b 00 	call	0xd6	; 0xd6 <LCD_Latch>
     14e:	85 ed       	ldi	r24, 0xD5	; 213
     150:	8a 95       	dec	r24
     152:	f1 f7       	brne	.-4      	; 0x150 <LCD_SendCMD+0x64>
     154:	00 00       	nop
     156:	cf 91       	pop	r28
     158:	08 95       	ret

0000015a <LCD_GotoXY>:
     15a:	28 2f       	mov	r18, r24
     15c:	30 e0       	ldi	r19, 0x00	; 0
     15e:	2f 5f       	subi	r18, 0xFF	; 255
     160:	3f 4f       	sbci	r19, 0xFF	; 255
     162:	86 2f       	mov	r24, r22
     164:	90 e4       	ldi	r25, 0x40	; 64
     166:	29 9f       	mul	r18, r25
     168:	80 0d       	add	r24, r0
     16a:	11 24       	eor	r1, r1
     16c:	81 50       	subi	r24, 0x01	; 1
     16e:	0e 94 76 00 	call	0xec	; 0xec <LCD_SendCMD>
     172:	08 95       	ret

00000174 <LCD_SendData>:
     174:	cf 93       	push	r28
     176:	c8 2f       	mov	r28, r24
     178:	8b b3       	in	r24, 0x1b	; 27
     17a:	88 60       	ori	r24, 0x08	; 8
     17c:	8b bb       	out	0x1b, r24	; 27
     17e:	88 b3       	in	r24, 0x18	; 24
     180:	88 7f       	andi	r24, 0xF8	; 248
     182:	88 bb       	out	0x18, r24	; 24
     184:	98 b3       	in	r25, 0x18	; 24
     186:	8c 2f       	mov	r24, r28
     188:	82 95       	swap	r24
     18a:	8f 70       	andi	r24, 0x0F	; 15
     18c:	28 2f       	mov	r18, r24
     18e:	27 70       	andi	r18, 0x07	; 7
     190:	92 2b       	or	r25, r18
     192:	98 bb       	out	0x18, r25	; 24
     194:	98 b3       	in	r25, 0x18	; 24
     196:	9f 7e       	andi	r25, 0xEF	; 239
     198:	98 bb       	out	0x18, r25	; 24
     19a:	28 b3       	in	r18, 0x18	; 24
     19c:	90 e0       	ldi	r25, 0x00	; 0
     19e:	88 0f       	add	r24, r24
     1a0:	99 1f       	adc	r25, r25
     1a2:	80 71       	andi	r24, 0x10	; 16
     1a4:	82 2b       	or	r24, r18
     1a6:	88 bb       	out	0x18, r24	; 24
     1a8:	0e 94 6b 00 	call	0xd6	; 0xd6 <LCD_Latch>
     1ac:	88 b3       	in	r24, 0x18	; 24
     1ae:	88 7f       	andi	r24, 0xF8	; 248
     1b0:	88 bb       	out	0x18, r24	; 24
     1b2:	88 b3       	in	r24, 0x18	; 24
     1b4:	9c 2f       	mov	r25, r28
     1b6:	97 70       	andi	r25, 0x07	; 7
     1b8:	89 2b       	or	r24, r25
     1ba:	88 bb       	out	0x18, r24	; 24
     1bc:	88 b3       	in	r24, 0x18	; 24
     1be:	8f 7e       	andi	r24, 0xEF	; 239
     1c0:	88 bb       	out	0x18, r24	; 24
     1c2:	28 b3       	in	r18, 0x18	; 24
     1c4:	8c 2f       	mov	r24, r28
     1c6:	90 e0       	ldi	r25, 0x00	; 0
     1c8:	88 0f       	add	r24, r24
     1ca:	99 1f       	adc	r25, r25
     1cc:	80 71       	andi	r24, 0x10	; 16
     1ce:	82 2b       	or	r24, r18
     1d0:	88 bb       	out	0x18, r24	; 24
     1d2:	0e 94 6b 00 	call	0xd6	; 0xd6 <LCD_Latch>
     1d6:	85 ed       	ldi	r24, 0xD5	; 213
     1d8:	8a 95       	dec	r24
     1da:	f1 f7       	brne	.-4      	; 0x1d8 <LCD_SendData+0x64>
     1dc:	00 00       	nop
     1de:	cf 91       	pop	r28
     1e0:	08 95       	ret

000001e2 <LCD_RetHome>:
     1e2:	82 e0       	ldi	r24, 0x02	; 2
     1e4:	0e 94 76 00 	call	0xec	; 0xec <LCD_SendCMD>
     1e8:	8f e1       	ldi	r24, 0x1F	; 31
     1ea:	9e e4       	ldi	r25, 0x4E	; 78
     1ec:	01 97       	sbiw	r24, 0x01	; 1
     1ee:	f1 f7       	brne	.-4      	; 0x1ec <LCD_RetHome+0xa>
     1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <LCD_RetHome+0x10>
     1f2:	00 00       	nop
     1f4:	08 95       	ret

000001f6 <LCD_Clear>:
     1f6:	81 e0       	ldi	r24, 0x01	; 1
     1f8:	0e 94 76 00 	call	0xec	; 0xec <LCD_SendCMD>
     1fc:	8f e1       	ldi	r24, 0x1F	; 31
     1fe:	9e e4       	ldi	r25, 0x4E	; 78
     200:	01 97       	sbiw	r24, 0x01	; 1
     202:	f1 f7       	brne	.-4      	; 0x200 <LCD_Clear+0xa>
     204:	00 c0       	rjmp	.+0      	; 0x206 <LCD_Clear+0x10>
     206:	00 00       	nop
     208:	08 95       	ret

0000020a <LCD_Init>:
     20a:	87 b3       	in	r24, 0x17	; 23
     20c:	87 60       	ori	r24, 0x07	; 7
     20e:	87 bb       	out	0x17, r24	; 23
     210:	87 b3       	in	r24, 0x17	; 23
     212:	80 61       	ori	r24, 0x10	; 16
     214:	87 bb       	out	0x17, r24	; 23
     216:	8a b3       	in	r24, 0x1a	; 26
     218:	88 60       	ori	r24, 0x08	; 8
     21a:	8a bb       	out	0x1a, r24	; 26
     21c:	8a b3       	in	r24, 0x1a	; 26
     21e:	84 60       	ori	r24, 0x04	; 4
     220:	8a bb       	out	0x1a, r24	; 26
     222:	2f ef       	ldi	r18, 0xFF	; 255
     224:	89 ef       	ldi	r24, 0xF9	; 249
     226:	90 e0       	ldi	r25, 0x00	; 0
     228:	21 50       	subi	r18, 0x01	; 1
     22a:	80 40       	sbci	r24, 0x00	; 0
     22c:	90 40       	sbci	r25, 0x00	; 0
     22e:	e1 f7       	brne	.-8      	; 0x228 <LCD_Init+0x1e>
     230:	00 c0       	rjmp	.+0      	; 0x232 <LCD_Init+0x28>
     232:	00 00       	nop
     234:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <LCD_RetHome>
     238:	88 e2       	ldi	r24, 0x28	; 40
     23a:	0e 94 76 00 	call	0xec	; 0xec <LCD_SendCMD>
     23e:	8c e0       	ldi	r24, 0x0C	; 12
     240:	0e 94 76 00 	call	0xec	; 0xec <LCD_SendCMD>
     244:	86 e0       	ldi	r24, 0x06	; 6
     246:	0e 94 76 00 	call	0xec	; 0xec <LCD_SendCMD>
     24a:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <LCD_Clear>
     24e:	08 95       	ret

00000250 <LCD_DispChar>:
     250:	0e 94 ba 00 	call	0x174	; 0x174 <LCD_SendData>
     254:	08 95       	ret

00000256 <LCD_DispStr>:
void LCD_DispStr(u8* str){
     256:	0f 93       	push	r16
     258:	1f 93       	push	r17
     25a:	cf 93       	push	r28
     25c:	8c 01       	movw	r16, r24
	u8 i = 0;
     25e:	c0 e0       	ldi	r28, 0x00	; 0
	while(str[i] != 0)
     260:	03 c0       	rjmp	.+6      	; 0x268 <LCD_DispStr+0x12>
	{
		LCD_DispChar(str[i]);
     262:	0e 94 28 01 	call	0x250	; 0x250 <LCD_DispChar>
		i++;
     266:	cf 5f       	subi	r28, 0xFF	; 255
	LCD_GotoXY(row,col);
	LCD_DispChar(data);
}
void LCD_DispStr(u8* str){
	u8 i = 0;
	while(str[i] != 0)
     268:	f8 01       	movw	r30, r16
     26a:	ec 0f       	add	r30, r28
     26c:	f1 1d       	adc	r31, r1
     26e:	80 81       	ld	r24, Z
     270:	81 11       	cpse	r24, r1
     272:	f7 cf       	rjmp	.-18     	; 0x262 <LCD_DispStr+0xc>
	{
		LCD_DispChar(str[i]);
		i++;
	}
}
     274:	cf 91       	pop	r28
     276:	1f 91       	pop	r17
     278:	0f 91       	pop	r16
     27a:	08 95       	ret

0000027c <LCD_DispStrXY>:
void LCD_DispStrXY(u8 row, u8 col, u8* str){
     27c:	cf 93       	push	r28
     27e:	df 93       	push	r29
     280:	ea 01       	movw	r28, r20
		LCD_GotoXY(row,col);
     282:	0e 94 ad 00 	call	0x15a	; 0x15a <LCD_GotoXY>
		LCD_DispStr(str);
     286:	ce 01       	movw	r24, r28
     288:	0e 94 2b 01 	call	0x256	; 0x256 <LCD_DispStr>
}
     28c:	df 91       	pop	r29
     28e:	cf 91       	pop	r28
     290:	08 95       	ret

00000292 <Uart_Init>:
	}
	else{
		result = FALSE;
	}
	return result;
}
     292:	dc 01       	movw	r26, r24
     294:	cb 01       	movw	r24, r22
     296:	88 0f       	add	r24, r24
     298:	99 1f       	adc	r25, r25
     29a:	aa 1f       	adc	r26, r26
     29c:	bb 1f       	adc	r27, r27
     29e:	88 0f       	add	r24, r24
     2a0:	99 1f       	adc	r25, r25
     2a2:	aa 1f       	adc	r26, r26
     2a4:	bb 1f       	adc	r27, r27
     2a6:	88 0f       	add	r24, r24
     2a8:	99 1f       	adc	r25, r25
     2aa:	aa 1f       	adc	r26, r26
     2ac:	bb 1f       	adc	r27, r27
     2ae:	88 0f       	add	r24, r24
     2b0:	99 1f       	adc	r25, r25
     2b2:	aa 1f       	adc	r26, r26
     2b4:	bb 1f       	adc	r27, r27
     2b6:	9c 01       	movw	r18, r24
     2b8:	ad 01       	movw	r20, r26
     2ba:	21 50       	subi	r18, 0x01	; 1
     2bc:	31 09       	sbc	r19, r1
     2be:	41 09       	sbc	r20, r1
     2c0:	51 09       	sbc	r21, r1
     2c2:	60 e0       	ldi	r22, 0x00	; 0
     2c4:	74 e2       	ldi	r23, 0x24	; 36
     2c6:	84 ef       	ldi	r24, 0xF4	; 244
     2c8:	90 e0       	ldi	r25, 0x00	; 0
     2ca:	0e 94 9d 0b 	call	0x173a	; 0x173a <__udivmodsi4>
     2ce:	30 bd       	out	0x20, r19	; 32
     2d0:	29 b9       	out	0x09, r18	; 9
     2d2:	88 e1       	ldi	r24, 0x18	; 24
     2d4:	8a b9       	out	0x0a, r24	; 10
     2d6:	86 e8       	ldi	r24, 0x86	; 134
     2d8:	80 bd       	out	0x20, r24	; 32
     2da:	08 95       	ret

000002dc <Uart_SendByte>:
     2dc:	5d 9b       	sbis	0x0b, 5	; 11
     2de:	fe cf       	rjmp	.-4      	; 0x2dc <Uart_SendByte>
     2e0:	8c b9       	out	0x0c, r24	; 12
     2e2:	08 95       	ret

000002e4 <Uart_SendStr>:

void	Uart_SendStr(u8* str){
     2e4:	cf 92       	push	r12
     2e6:	df 92       	push	r13
     2e8:	ef 92       	push	r14
     2ea:	ff 92       	push	r15
     2ec:	cf 93       	push	r28
     2ee:	df 93       	push	r29
     2f0:	ec 01       	movw	r28, r24
	u32 ind = 0;
     2f2:	c1 2c       	mov	r12, r1
     2f4:	d1 2c       	mov	r13, r1
     2f6:	76 01       	movw	r14, r12
	while(str[ind] != 0){
     2f8:	07 c0       	rjmp	.+14     	; 0x308 <Uart_SendStr+0x24>
		Uart_SendByte(str[ind]);
     2fa:	0e 94 6e 01 	call	0x2dc	; 0x2dc <Uart_SendByte>
		ind++;
     2fe:	8f ef       	ldi	r24, 0xFF	; 255
     300:	c8 1a       	sub	r12, r24
     302:	d8 0a       	sbc	r13, r24
     304:	e8 0a       	sbc	r14, r24
     306:	f8 0a       	sbc	r15, r24
	return result;
}

void	Uart_SendStr(u8* str){
	u32 ind = 0;
	while(str[ind] != 0){
     308:	fe 01       	movw	r30, r28
     30a:	ec 0d       	add	r30, r12
     30c:	fd 1d       	adc	r31, r13
     30e:	80 81       	ld	r24, Z
     310:	81 11       	cpse	r24, r1
     312:	f3 cf       	rjmp	.-26     	; 0x2fa <Uart_SendStr+0x16>
		Uart_SendByte(str[ind]);
		ind++;
	}
     314:	df 91       	pop	r29
     316:	cf 91       	pop	r28
     318:	ff 90       	pop	r15
     31a:	ef 90       	pop	r14
     31c:	df 90       	pop	r13
     31e:	cf 90       	pop	r12
     320:	08 95       	ret

00000322 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     322:	cf 93       	push	r28
     324:	df 93       	push	r29
     326:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     328:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     32c:	80 91 94 00 	lds	r24, 0x0094	; 0x800094 <__data_end>
     330:	90 91 95 00 	lds	r25, 0x0095	; 0x800095 <__data_end+0x1>
     334:	89 2b       	or	r24, r25
     336:	31 f4       	brne	.+12     	; 0x344 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     338:	89 e9       	ldi	r24, 0x99	; 153
     33a:	90 e0       	ldi	r25, 0x00	; 0
     33c:	90 93 95 00 	sts	0x0095, r25	; 0x800095 <__data_end+0x1>
     340:	80 93 94 00 	sts	0x0094, r24	; 0x800094 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     344:	20 91 96 00 	lds	r18, 0x0096	; 0x800096 <xNextFreeByte>
     348:	30 91 97 00 	lds	r19, 0x0097	; 0x800097 <xNextFreeByte+0x1>
     34c:	c9 01       	movw	r24, r18
     34e:	8c 0f       	add	r24, r28
     350:	9d 1f       	adc	r25, r29
     352:	8d 37       	cpi	r24, 0x7D	; 125
     354:	44 e0       	ldi	r20, 0x04	; 4
     356:	94 07       	cpc	r25, r20
     358:	70 f4       	brcc	.+28     	; 0x376 <pvPortMalloc+0x54>
     35a:	28 17       	cp	r18, r24
     35c:	39 07       	cpc	r19, r25
     35e:	70 f4       	brcc	.+28     	; 0x37c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     360:	c0 91 94 00 	lds	r28, 0x0094	; 0x800094 <__data_end>
     364:	d0 91 95 00 	lds	r29, 0x0095	; 0x800095 <__data_end+0x1>
     368:	c2 0f       	add	r28, r18
     36a:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     36c:	90 93 97 00 	sts	0x0097, r25	; 0x800097 <xNextFreeByte+0x1>
     370:	80 93 96 00 	sts	0x0096, r24	; 0x800096 <xNextFreeByte>
     374:	05 c0       	rjmp	.+10     	; 0x380 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     376:	c0 e0       	ldi	r28, 0x00	; 0
     378:	d0 e0       	ldi	r29, 0x00	; 0
     37a:	02 c0       	rjmp	.+4      	; 0x380 <pvPortMalloc+0x5e>
     37c:	c0 e0       	ldi	r28, 0x00	; 0
     37e:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     380:	0e 94 88 08 	call	0x1110	; 0x1110 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     384:	ce 01       	movw	r24, r28
     386:	df 91       	pop	r29
     388:	cf 91       	pop	r28
     38a:	08 95       	ret

0000038c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     38c:	08 95       	ret

0000038e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     38e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     390:	03 96       	adiw	r24, 0x03	; 3
     392:	92 83       	std	Z+2, r25	; 0x02
     394:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     396:	2f ef       	ldi	r18, 0xFF	; 255
     398:	3f ef       	ldi	r19, 0xFF	; 255
     39a:	34 83       	std	Z+4, r19	; 0x04
     39c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     39e:	96 83       	std	Z+6, r25	; 0x06
     3a0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3a2:	90 87       	std	Z+8, r25	; 0x08
     3a4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     3a6:	10 82       	st	Z, r1
     3a8:	08 95       	ret

000003aa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     3aa:	fc 01       	movw	r30, r24
     3ac:	11 86       	std	Z+9, r1	; 0x09
     3ae:	10 86       	std	Z+8, r1	; 0x08
     3b0:	08 95       	ret

000003b2 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     3b2:	cf 93       	push	r28
     3b4:	df 93       	push	r29
     3b6:	9c 01       	movw	r18, r24
     3b8:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     3ba:	dc 01       	movw	r26, r24
     3bc:	11 96       	adiw	r26, 0x01	; 1
     3be:	cd 91       	ld	r28, X+
     3c0:	dc 91       	ld	r29, X
     3c2:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     3c4:	d3 83       	std	Z+3, r29	; 0x03
     3c6:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     3c8:	8c 81       	ldd	r24, Y+4	; 0x04
     3ca:	9d 81       	ldd	r25, Y+5	; 0x05
     3cc:	95 83       	std	Z+5, r25	; 0x05
     3ce:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     3d0:	8c 81       	ldd	r24, Y+4	; 0x04
     3d2:	9d 81       	ldd	r25, Y+5	; 0x05
     3d4:	dc 01       	movw	r26, r24
     3d6:	13 96       	adiw	r26, 0x03	; 3
     3d8:	7c 93       	st	X, r23
     3da:	6e 93       	st	-X, r22
     3dc:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     3de:	7d 83       	std	Y+5, r23	; 0x05
     3e0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3e2:	31 87       	std	Z+9, r19	; 0x09
     3e4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     3e6:	f9 01       	movw	r30, r18
     3e8:	80 81       	ld	r24, Z
     3ea:	8f 5f       	subi	r24, 0xFF	; 255
     3ec:	80 83       	st	Z, r24
}
     3ee:	df 91       	pop	r29
     3f0:	cf 91       	pop	r28
     3f2:	08 95       	ret

000003f4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     3f4:	cf 93       	push	r28
     3f6:	df 93       	push	r29
     3f8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     3fa:	48 81       	ld	r20, Y
     3fc:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     3fe:	4f 3f       	cpi	r20, 0xFF	; 255
     400:	2f ef       	ldi	r18, 0xFF	; 255
     402:	52 07       	cpc	r21, r18
     404:	21 f4       	brne	.+8      	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     406:	fc 01       	movw	r30, r24
     408:	a7 81       	ldd	r26, Z+7	; 0x07
     40a:	b0 85       	ldd	r27, Z+8	; 0x08
     40c:	0d c0       	rjmp	.+26     	; 0x428 <__EEPROM_REGION_LENGTH__+0x28>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     40e:	dc 01       	movw	r26, r24
     410:	13 96       	adiw	r26, 0x03	; 3
     412:	01 c0       	rjmp	.+2      	; 0x416 <__EEPROM_REGION_LENGTH__+0x16>
     414:	df 01       	movw	r26, r30
     416:	12 96       	adiw	r26, 0x02	; 2
     418:	ed 91       	ld	r30, X+
     41a:	fc 91       	ld	r31, X
     41c:	13 97       	sbiw	r26, 0x03	; 3
     41e:	20 81       	ld	r18, Z
     420:	31 81       	ldd	r19, Z+1	; 0x01
     422:	42 17       	cp	r20, r18
     424:	53 07       	cpc	r21, r19
     426:	b0 f7       	brcc	.-20     	; 0x414 <__EEPROM_REGION_LENGTH__+0x14>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     428:	12 96       	adiw	r26, 0x02	; 2
     42a:	ed 91       	ld	r30, X+
     42c:	fc 91       	ld	r31, X
     42e:	13 97       	sbiw	r26, 0x03	; 3
     430:	fb 83       	std	Y+3, r31	; 0x03
     432:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     434:	d5 83       	std	Z+5, r29	; 0x05
     436:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     438:	bd 83       	std	Y+5, r27	; 0x05
     43a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     43c:	13 96       	adiw	r26, 0x03	; 3
     43e:	dc 93       	st	X, r29
     440:	ce 93       	st	-X, r28
     442:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     444:	99 87       	std	Y+9, r25	; 0x09
     446:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     448:	fc 01       	movw	r30, r24
     44a:	20 81       	ld	r18, Z
     44c:	2f 5f       	subi	r18, 0xFF	; 255
     44e:	20 83       	st	Z, r18
}
     450:	df 91       	pop	r29
     452:	cf 91       	pop	r28
     454:	08 95       	ret

00000456 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     456:	cf 93       	push	r28
     458:	df 93       	push	r29
     45a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     45c:	a0 85       	ldd	r26, Z+8	; 0x08
     45e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     460:	c2 81       	ldd	r28, Z+2	; 0x02
     462:	d3 81       	ldd	r29, Z+3	; 0x03
     464:	84 81       	ldd	r24, Z+4	; 0x04
     466:	95 81       	ldd	r25, Z+5	; 0x05
     468:	9d 83       	std	Y+5, r25	; 0x05
     46a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     46c:	c4 81       	ldd	r28, Z+4	; 0x04
     46e:	d5 81       	ldd	r29, Z+5	; 0x05
     470:	82 81       	ldd	r24, Z+2	; 0x02
     472:	93 81       	ldd	r25, Z+3	; 0x03
     474:	9b 83       	std	Y+3, r25	; 0x03
     476:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     478:	11 96       	adiw	r26, 0x01	; 1
     47a:	8d 91       	ld	r24, X+
     47c:	9c 91       	ld	r25, X
     47e:	12 97       	sbiw	r26, 0x02	; 2
     480:	e8 17       	cp	r30, r24
     482:	f9 07       	cpc	r31, r25
     484:	31 f4       	brne	.+12     	; 0x492 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     486:	84 81       	ldd	r24, Z+4	; 0x04
     488:	95 81       	ldd	r25, Z+5	; 0x05
     48a:	12 96       	adiw	r26, 0x02	; 2
     48c:	9c 93       	st	X, r25
     48e:	8e 93       	st	-X, r24
     490:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     492:	11 86       	std	Z+9, r1	; 0x09
     494:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     496:	8c 91       	ld	r24, X
     498:	81 50       	subi	r24, 0x01	; 1
     49a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     49c:	df 91       	pop	r29
     49e:	cf 91       	pop	r28
     4a0:	08 95       	ret

000004a2 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     4a2:	1b bc       	out	0x2b, r1	; 43
     4a4:	89 ef       	ldi	r24, 0xF9	; 249
     4a6:	8a bd       	out	0x2a, r24	; 42
     4a8:	8b e0       	ldi	r24, 0x0B	; 11
     4aa:	8e bd       	out	0x2e, r24	; 46
     4ac:	89 b7       	in	r24, 0x39	; 57
     4ae:	80 61       	ori	r24, 0x10	; 16
     4b0:	89 bf       	out	0x39, r24	; 57
     4b2:	08 95       	ret

000004b4 <pxPortInitialiseStack>:
     4b4:	31 e1       	ldi	r19, 0x11	; 17
     4b6:	fc 01       	movw	r30, r24
     4b8:	30 83       	st	Z, r19
     4ba:	31 97       	sbiw	r30, 0x01	; 1
     4bc:	22 e2       	ldi	r18, 0x22	; 34
     4be:	20 83       	st	Z, r18
     4c0:	31 97       	sbiw	r30, 0x01	; 1
     4c2:	a3 e3       	ldi	r26, 0x33	; 51
     4c4:	a0 83       	st	Z, r26
     4c6:	31 97       	sbiw	r30, 0x01	; 1
     4c8:	60 83       	st	Z, r22
     4ca:	31 97       	sbiw	r30, 0x01	; 1
     4cc:	70 83       	st	Z, r23
     4ce:	31 97       	sbiw	r30, 0x01	; 1
     4d0:	10 82       	st	Z, r1
     4d2:	31 97       	sbiw	r30, 0x01	; 1
     4d4:	60 e8       	ldi	r22, 0x80	; 128
     4d6:	60 83       	st	Z, r22
     4d8:	31 97       	sbiw	r30, 0x01	; 1
     4da:	10 82       	st	Z, r1
     4dc:	31 97       	sbiw	r30, 0x01	; 1
     4de:	62 e0       	ldi	r22, 0x02	; 2
     4e0:	60 83       	st	Z, r22
     4e2:	31 97       	sbiw	r30, 0x01	; 1
     4e4:	63 e0       	ldi	r22, 0x03	; 3
     4e6:	60 83       	st	Z, r22
     4e8:	31 97       	sbiw	r30, 0x01	; 1
     4ea:	64 e0       	ldi	r22, 0x04	; 4
     4ec:	60 83       	st	Z, r22
     4ee:	31 97       	sbiw	r30, 0x01	; 1
     4f0:	65 e0       	ldi	r22, 0x05	; 5
     4f2:	60 83       	st	Z, r22
     4f4:	31 97       	sbiw	r30, 0x01	; 1
     4f6:	66 e0       	ldi	r22, 0x06	; 6
     4f8:	60 83       	st	Z, r22
     4fa:	31 97       	sbiw	r30, 0x01	; 1
     4fc:	67 e0       	ldi	r22, 0x07	; 7
     4fe:	60 83       	st	Z, r22
     500:	31 97       	sbiw	r30, 0x01	; 1
     502:	68 e0       	ldi	r22, 0x08	; 8
     504:	60 83       	st	Z, r22
     506:	31 97       	sbiw	r30, 0x01	; 1
     508:	69 e0       	ldi	r22, 0x09	; 9
     50a:	60 83       	st	Z, r22
     50c:	31 97       	sbiw	r30, 0x01	; 1
     50e:	60 e1       	ldi	r22, 0x10	; 16
     510:	60 83       	st	Z, r22
     512:	31 97       	sbiw	r30, 0x01	; 1
     514:	30 83       	st	Z, r19
     516:	31 97       	sbiw	r30, 0x01	; 1
     518:	32 e1       	ldi	r19, 0x12	; 18
     51a:	30 83       	st	Z, r19
     51c:	31 97       	sbiw	r30, 0x01	; 1
     51e:	33 e1       	ldi	r19, 0x13	; 19
     520:	30 83       	st	Z, r19
     522:	31 97       	sbiw	r30, 0x01	; 1
     524:	34 e1       	ldi	r19, 0x14	; 20
     526:	30 83       	st	Z, r19
     528:	31 97       	sbiw	r30, 0x01	; 1
     52a:	35 e1       	ldi	r19, 0x15	; 21
     52c:	30 83       	st	Z, r19
     52e:	31 97       	sbiw	r30, 0x01	; 1
     530:	36 e1       	ldi	r19, 0x16	; 22
     532:	30 83       	st	Z, r19
     534:	31 97       	sbiw	r30, 0x01	; 1
     536:	37 e1       	ldi	r19, 0x17	; 23
     538:	30 83       	st	Z, r19
     53a:	31 97       	sbiw	r30, 0x01	; 1
     53c:	38 e1       	ldi	r19, 0x18	; 24
     53e:	30 83       	st	Z, r19
     540:	31 97       	sbiw	r30, 0x01	; 1
     542:	39 e1       	ldi	r19, 0x19	; 25
     544:	30 83       	st	Z, r19
     546:	31 97       	sbiw	r30, 0x01	; 1
     548:	30 e2       	ldi	r19, 0x20	; 32
     54a:	30 83       	st	Z, r19
     54c:	31 97       	sbiw	r30, 0x01	; 1
     54e:	31 e2       	ldi	r19, 0x21	; 33
     550:	30 83       	st	Z, r19
     552:	31 97       	sbiw	r30, 0x01	; 1
     554:	20 83       	st	Z, r18
     556:	31 97       	sbiw	r30, 0x01	; 1
     558:	23 e2       	ldi	r18, 0x23	; 35
     55a:	20 83       	st	Z, r18
     55c:	31 97       	sbiw	r30, 0x01	; 1
     55e:	40 83       	st	Z, r20
     560:	31 97       	sbiw	r30, 0x01	; 1
     562:	50 83       	st	Z, r21
     564:	31 97       	sbiw	r30, 0x01	; 1
     566:	26 e2       	ldi	r18, 0x26	; 38
     568:	20 83       	st	Z, r18
     56a:	31 97       	sbiw	r30, 0x01	; 1
     56c:	27 e2       	ldi	r18, 0x27	; 39
     56e:	20 83       	st	Z, r18
     570:	31 97       	sbiw	r30, 0x01	; 1
     572:	28 e2       	ldi	r18, 0x28	; 40
     574:	20 83       	st	Z, r18
     576:	31 97       	sbiw	r30, 0x01	; 1
     578:	29 e2       	ldi	r18, 0x29	; 41
     57a:	20 83       	st	Z, r18
     57c:	31 97       	sbiw	r30, 0x01	; 1
     57e:	20 e3       	ldi	r18, 0x30	; 48
     580:	20 83       	st	Z, r18
     582:	31 97       	sbiw	r30, 0x01	; 1
     584:	21 e3       	ldi	r18, 0x31	; 49
     586:	20 83       	st	Z, r18
     588:	86 97       	sbiw	r24, 0x26	; 38
     58a:	08 95       	ret

0000058c <xPortStartScheduler>:
     58c:	0e 94 51 02 	call	0x4a2	; 0x4a2 <prvSetupTimerInterrupt>
     590:	a0 91 6d 05 	lds	r26, 0x056D	; 0x80056d <pxCurrentTCB>
     594:	b0 91 6e 05 	lds	r27, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
     598:	cd 91       	ld	r28, X+
     59a:	cd bf       	out	0x3d, r28	; 61
     59c:	dd 91       	ld	r29, X+
     59e:	de bf       	out	0x3e, r29	; 62
     5a0:	ff 91       	pop	r31
     5a2:	ef 91       	pop	r30
     5a4:	df 91       	pop	r29
     5a6:	cf 91       	pop	r28
     5a8:	bf 91       	pop	r27
     5aa:	af 91       	pop	r26
     5ac:	9f 91       	pop	r25
     5ae:	8f 91       	pop	r24
     5b0:	7f 91       	pop	r23
     5b2:	6f 91       	pop	r22
     5b4:	5f 91       	pop	r21
     5b6:	4f 91       	pop	r20
     5b8:	3f 91       	pop	r19
     5ba:	2f 91       	pop	r18
     5bc:	1f 91       	pop	r17
     5be:	0f 91       	pop	r16
     5c0:	ff 90       	pop	r15
     5c2:	ef 90       	pop	r14
     5c4:	df 90       	pop	r13
     5c6:	cf 90       	pop	r12
     5c8:	bf 90       	pop	r11
     5ca:	af 90       	pop	r10
     5cc:	9f 90       	pop	r9
     5ce:	8f 90       	pop	r8
     5d0:	7f 90       	pop	r7
     5d2:	6f 90       	pop	r6
     5d4:	5f 90       	pop	r5
     5d6:	4f 90       	pop	r4
     5d8:	3f 90       	pop	r3
     5da:	2f 90       	pop	r2
     5dc:	1f 90       	pop	r1
     5de:	0f 90       	pop	r0
     5e0:	0f be       	out	0x3f, r0	; 63
     5e2:	0f 90       	pop	r0
     5e4:	08 95       	ret
     5e6:	81 e0       	ldi	r24, 0x01	; 1
     5e8:	08 95       	ret

000005ea <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     5ea:	0f 92       	push	r0
     5ec:	0f b6       	in	r0, 0x3f	; 63
     5ee:	f8 94       	cli
     5f0:	0f 92       	push	r0
     5f2:	1f 92       	push	r1
     5f4:	11 24       	eor	r1, r1
     5f6:	2f 92       	push	r2
     5f8:	3f 92       	push	r3
     5fa:	4f 92       	push	r4
     5fc:	5f 92       	push	r5
     5fe:	6f 92       	push	r6
     600:	7f 92       	push	r7
     602:	8f 92       	push	r8
     604:	9f 92       	push	r9
     606:	af 92       	push	r10
     608:	bf 92       	push	r11
     60a:	cf 92       	push	r12
     60c:	df 92       	push	r13
     60e:	ef 92       	push	r14
     610:	ff 92       	push	r15
     612:	0f 93       	push	r16
     614:	1f 93       	push	r17
     616:	2f 93       	push	r18
     618:	3f 93       	push	r19
     61a:	4f 93       	push	r20
     61c:	5f 93       	push	r21
     61e:	6f 93       	push	r22
     620:	7f 93       	push	r23
     622:	8f 93       	push	r24
     624:	9f 93       	push	r25
     626:	af 93       	push	r26
     628:	bf 93       	push	r27
     62a:	cf 93       	push	r28
     62c:	df 93       	push	r29
     62e:	ef 93       	push	r30
     630:	ff 93       	push	r31
     632:	a0 91 6d 05 	lds	r26, 0x056D	; 0x80056d <pxCurrentTCB>
     636:	b0 91 6e 05 	lds	r27, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
     63a:	0d b6       	in	r0, 0x3d	; 61
     63c:	0d 92       	st	X+, r0
     63e:	0e b6       	in	r0, 0x3e	; 62
     640:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     642:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     646:	a0 91 6d 05 	lds	r26, 0x056D	; 0x80056d <pxCurrentTCB>
     64a:	b0 91 6e 05 	lds	r27, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
     64e:	cd 91       	ld	r28, X+
     650:	cd bf       	out	0x3d, r28	; 61
     652:	dd 91       	ld	r29, X+
     654:	de bf       	out	0x3e, r29	; 62
     656:	ff 91       	pop	r31
     658:	ef 91       	pop	r30
     65a:	df 91       	pop	r29
     65c:	cf 91       	pop	r28
     65e:	bf 91       	pop	r27
     660:	af 91       	pop	r26
     662:	9f 91       	pop	r25
     664:	8f 91       	pop	r24
     666:	7f 91       	pop	r23
     668:	6f 91       	pop	r22
     66a:	5f 91       	pop	r21
     66c:	4f 91       	pop	r20
     66e:	3f 91       	pop	r19
     670:	2f 91       	pop	r18
     672:	1f 91       	pop	r17
     674:	0f 91       	pop	r16
     676:	ff 90       	pop	r15
     678:	ef 90       	pop	r14
     67a:	df 90       	pop	r13
     67c:	cf 90       	pop	r12
     67e:	bf 90       	pop	r11
     680:	af 90       	pop	r10
     682:	9f 90       	pop	r9
     684:	8f 90       	pop	r8
     686:	7f 90       	pop	r7
     688:	6f 90       	pop	r6
     68a:	5f 90       	pop	r5
     68c:	4f 90       	pop	r4
     68e:	3f 90       	pop	r3
     690:	2f 90       	pop	r2
     692:	1f 90       	pop	r1
     694:	0f 90       	pop	r0
     696:	0f be       	out	0x3f, r0	; 63
     698:	0f 90       	pop	r0

	asm volatile ( "ret" );
     69a:	08 95       	ret

0000069c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     69c:	0f 92       	push	r0
     69e:	0f b6       	in	r0, 0x3f	; 63
     6a0:	f8 94       	cli
     6a2:	0f 92       	push	r0
     6a4:	1f 92       	push	r1
     6a6:	11 24       	eor	r1, r1
     6a8:	2f 92       	push	r2
     6aa:	3f 92       	push	r3
     6ac:	4f 92       	push	r4
     6ae:	5f 92       	push	r5
     6b0:	6f 92       	push	r6
     6b2:	7f 92       	push	r7
     6b4:	8f 92       	push	r8
     6b6:	9f 92       	push	r9
     6b8:	af 92       	push	r10
     6ba:	bf 92       	push	r11
     6bc:	cf 92       	push	r12
     6be:	df 92       	push	r13
     6c0:	ef 92       	push	r14
     6c2:	ff 92       	push	r15
     6c4:	0f 93       	push	r16
     6c6:	1f 93       	push	r17
     6c8:	2f 93       	push	r18
     6ca:	3f 93       	push	r19
     6cc:	4f 93       	push	r20
     6ce:	5f 93       	push	r21
     6d0:	6f 93       	push	r22
     6d2:	7f 93       	push	r23
     6d4:	8f 93       	push	r24
     6d6:	9f 93       	push	r25
     6d8:	af 93       	push	r26
     6da:	bf 93       	push	r27
     6dc:	cf 93       	push	r28
     6de:	df 93       	push	r29
     6e0:	ef 93       	push	r30
     6e2:	ff 93       	push	r31
     6e4:	a0 91 6d 05 	lds	r26, 0x056D	; 0x80056d <pxCurrentTCB>
     6e8:	b0 91 6e 05 	lds	r27, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
     6ec:	0d b6       	in	r0, 0x3d	; 61
     6ee:	0d 92       	st	X+, r0
     6f0:	0e b6       	in	r0, 0x3e	; 62
     6f2:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     6f4:	0e 94 cc 07 	call	0xf98	; 0xf98 <xTaskIncrementTick>
     6f8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     6fa:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     6fe:	a0 91 6d 05 	lds	r26, 0x056D	; 0x80056d <pxCurrentTCB>
     702:	b0 91 6e 05 	lds	r27, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
     706:	cd 91       	ld	r28, X+
     708:	cd bf       	out	0x3d, r28	; 61
     70a:	dd 91       	ld	r29, X+
     70c:	de bf       	out	0x3e, r29	; 62
     70e:	ff 91       	pop	r31
     710:	ef 91       	pop	r30
     712:	df 91       	pop	r29
     714:	cf 91       	pop	r28
     716:	bf 91       	pop	r27
     718:	af 91       	pop	r26
     71a:	9f 91       	pop	r25
     71c:	8f 91       	pop	r24
     71e:	7f 91       	pop	r23
     720:	6f 91       	pop	r22
     722:	5f 91       	pop	r21
     724:	4f 91       	pop	r20
     726:	3f 91       	pop	r19
     728:	2f 91       	pop	r18
     72a:	1f 91       	pop	r17
     72c:	0f 91       	pop	r16
     72e:	ff 90       	pop	r15
     730:	ef 90       	pop	r14
     732:	df 90       	pop	r13
     734:	cf 90       	pop	r12
     736:	bf 90       	pop	r11
     738:	af 90       	pop	r10
     73a:	9f 90       	pop	r9
     73c:	8f 90       	pop	r8
     73e:	7f 90       	pop	r7
     740:	6f 90       	pop	r6
     742:	5f 90       	pop	r5
     744:	4f 90       	pop	r4
     746:	3f 90       	pop	r3
     748:	2f 90       	pop	r2
     74a:	1f 90       	pop	r1
     74c:	0f 90       	pop	r0
     74e:	0f be       	out	0x3f, r0	; 63
     750:	0f 90       	pop	r0

	asm volatile ( "ret" );
     752:	08 95       	ret

00000754 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     754:	0e 94 4e 03 	call	0x69c	; 0x69c <vPortYieldFromTick>
		asm volatile ( "reti" );
     758:	18 95       	reti

0000075a <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     75a:	0f b6       	in	r0, 0x3f	; 63
     75c:	f8 94       	cli
     75e:	0f 92       	push	r0
     760:	fc 01       	movw	r30, r24
     762:	82 8d       	ldd	r24, Z+26	; 0x1a
     764:	81 11       	cpse	r24, r1
     766:	02 c0       	rjmp	.+4      	; 0x76c <prvIsQueueEmpty+0x12>
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	01 c0       	rjmp	.+2      	; 0x76e <prvIsQueueEmpty+0x14>
     76c:	80 e0       	ldi	r24, 0x00	; 0
     76e:	0f 90       	pop	r0
     770:	0f be       	out	0x3f, r0	; 63
     772:	08 95       	ret

00000774 <prvIsQueueFull>:
     774:	0f b6       	in	r0, 0x3f	; 63
     776:	f8 94       	cli
     778:	0f 92       	push	r0
     77a:	fc 01       	movw	r30, r24
     77c:	22 8d       	ldd	r18, Z+26	; 0x1a
     77e:	83 8d       	ldd	r24, Z+27	; 0x1b
     780:	28 13       	cpse	r18, r24
     782:	02 c0       	rjmp	.+4      	; 0x788 <prvIsQueueFull+0x14>
     784:	81 e0       	ldi	r24, 0x01	; 1
     786:	01 c0       	rjmp	.+2      	; 0x78a <prvIsQueueFull+0x16>
     788:	80 e0       	ldi	r24, 0x00	; 0
     78a:	0f 90       	pop	r0
     78c:	0f be       	out	0x3f, r0	; 63
     78e:	08 95       	ret

00000790 <prvCopyDataToQueue>:
     790:	1f 93       	push	r17
     792:	cf 93       	push	r28
     794:	df 93       	push	r29
     796:	ec 01       	movw	r28, r24
     798:	14 2f       	mov	r17, r20
     79a:	4c 8d       	ldd	r20, Y+28	; 0x1c
     79c:	41 11       	cpse	r20, r1
     79e:	0c c0       	rjmp	.+24     	; 0x7b8 <prvCopyDataToQueue+0x28>
     7a0:	88 81       	ld	r24, Y
     7a2:	99 81       	ldd	r25, Y+1	; 0x01
     7a4:	89 2b       	or	r24, r25
     7a6:	09 f0       	breq	.+2      	; 0x7aa <prvCopyDataToQueue+0x1a>
     7a8:	45 c0       	rjmp	.+138    	; 0x834 <__DATA_REGION_LENGTH__+0x34>
     7aa:	8a 81       	ldd	r24, Y+2	; 0x02
     7ac:	9b 81       	ldd	r25, Y+3	; 0x03
     7ae:	0e 94 b6 0a 	call	0x156c	; 0x156c <xTaskPriorityDisinherit>
     7b2:	1b 82       	std	Y+3, r1	; 0x03
     7b4:	1a 82       	std	Y+2, r1	; 0x02
     7b6:	45 c0       	rjmp	.+138    	; 0x842 <__DATA_REGION_LENGTH__+0x42>
     7b8:	11 11       	cpse	r17, r1
     7ba:	17 c0       	rjmp	.+46     	; 0x7ea <prvCopyDataToQueue+0x5a>
     7bc:	50 e0       	ldi	r21, 0x00	; 0
     7be:	8c 81       	ldd	r24, Y+4	; 0x04
     7c0:	9d 81       	ldd	r25, Y+5	; 0x05
     7c2:	0e 94 bf 0b 	call	0x177e	; 0x177e <memcpy>
     7c6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     7c8:	8c 81       	ldd	r24, Y+4	; 0x04
     7ca:	9d 81       	ldd	r25, Y+5	; 0x05
     7cc:	82 0f       	add	r24, r18
     7ce:	91 1d       	adc	r25, r1
     7d0:	9d 83       	std	Y+5, r25	; 0x05
     7d2:	8c 83       	std	Y+4, r24	; 0x04
     7d4:	2a 81       	ldd	r18, Y+2	; 0x02
     7d6:	3b 81       	ldd	r19, Y+3	; 0x03
     7d8:	82 17       	cp	r24, r18
     7da:	93 07       	cpc	r25, r19
     7dc:	68 f1       	brcs	.+90     	; 0x838 <__DATA_REGION_LENGTH__+0x38>
     7de:	88 81       	ld	r24, Y
     7e0:	99 81       	ldd	r25, Y+1	; 0x01
     7e2:	9d 83       	std	Y+5, r25	; 0x05
     7e4:	8c 83       	std	Y+4, r24	; 0x04
     7e6:	80 e0       	ldi	r24, 0x00	; 0
     7e8:	2c c0       	rjmp	.+88     	; 0x842 <__DATA_REGION_LENGTH__+0x42>
     7ea:	50 e0       	ldi	r21, 0x00	; 0
     7ec:	8e 81       	ldd	r24, Y+6	; 0x06
     7ee:	9f 81       	ldd	r25, Y+7	; 0x07
     7f0:	0e 94 bf 0b 	call	0x177e	; 0x177e <memcpy>
     7f4:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	91 95       	neg	r25
     7fa:	81 95       	neg	r24
     7fc:	91 09       	sbc	r25, r1
     7fe:	2e 81       	ldd	r18, Y+6	; 0x06
     800:	3f 81       	ldd	r19, Y+7	; 0x07
     802:	28 0f       	add	r18, r24
     804:	39 1f       	adc	r19, r25
     806:	3f 83       	std	Y+7, r19	; 0x07
     808:	2e 83       	std	Y+6, r18	; 0x06
     80a:	48 81       	ld	r20, Y
     80c:	59 81       	ldd	r21, Y+1	; 0x01
     80e:	24 17       	cp	r18, r20
     810:	35 07       	cpc	r19, r21
     812:	30 f4       	brcc	.+12     	; 0x820 <__DATA_REGION_LENGTH__+0x20>
     814:	2a 81       	ldd	r18, Y+2	; 0x02
     816:	3b 81       	ldd	r19, Y+3	; 0x03
     818:	82 0f       	add	r24, r18
     81a:	93 1f       	adc	r25, r19
     81c:	9f 83       	std	Y+7, r25	; 0x07
     81e:	8e 83       	std	Y+6, r24	; 0x06
     820:	12 30       	cpi	r17, 0x02	; 2
     822:	61 f4       	brne	.+24     	; 0x83c <__DATA_REGION_LENGTH__+0x3c>
     824:	8a 8d       	ldd	r24, Y+26	; 0x1a
     826:	88 23       	and	r24, r24
     828:	59 f0       	breq	.+22     	; 0x840 <__DATA_REGION_LENGTH__+0x40>
     82a:	8a 8d       	ldd	r24, Y+26	; 0x1a
     82c:	81 50       	subi	r24, 0x01	; 1
     82e:	8a 8f       	std	Y+26, r24	; 0x1a
     830:	80 e0       	ldi	r24, 0x00	; 0
     832:	07 c0       	rjmp	.+14     	; 0x842 <__DATA_REGION_LENGTH__+0x42>
     834:	80 e0       	ldi	r24, 0x00	; 0
     836:	05 c0       	rjmp	.+10     	; 0x842 <__DATA_REGION_LENGTH__+0x42>
     838:	80 e0       	ldi	r24, 0x00	; 0
     83a:	03 c0       	rjmp	.+6      	; 0x842 <__DATA_REGION_LENGTH__+0x42>
     83c:	80 e0       	ldi	r24, 0x00	; 0
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__DATA_REGION_LENGTH__+0x42>
     840:	80 e0       	ldi	r24, 0x00	; 0
     842:	9a 8d       	ldd	r25, Y+26	; 0x1a
     844:	9f 5f       	subi	r25, 0xFF	; 255
     846:	9a 8f       	std	Y+26, r25	; 0x1a
     848:	df 91       	pop	r29
     84a:	cf 91       	pop	r28
     84c:	1f 91       	pop	r17
     84e:	08 95       	ret

00000850 <prvCopyDataFromQueue>:
     850:	fc 01       	movw	r30, r24
     852:	44 8d       	ldd	r20, Z+28	; 0x1c
     854:	44 23       	and	r20, r20
     856:	a9 f0       	breq	.+42     	; 0x882 <__stack+0x23>
     858:	50 e0       	ldi	r21, 0x00	; 0
     85a:	26 81       	ldd	r18, Z+6	; 0x06
     85c:	37 81       	ldd	r19, Z+7	; 0x07
     85e:	24 0f       	add	r18, r20
     860:	35 1f       	adc	r19, r21
     862:	37 83       	std	Z+7, r19	; 0x07
     864:	26 83       	std	Z+6, r18	; 0x06
     866:	82 81       	ldd	r24, Z+2	; 0x02
     868:	93 81       	ldd	r25, Z+3	; 0x03
     86a:	28 17       	cp	r18, r24
     86c:	39 07       	cpc	r19, r25
     86e:	20 f0       	brcs	.+8      	; 0x878 <__stack+0x19>
     870:	80 81       	ld	r24, Z
     872:	91 81       	ldd	r25, Z+1	; 0x01
     874:	97 83       	std	Z+7, r25	; 0x07
     876:	86 83       	std	Z+6, r24	; 0x06
     878:	cb 01       	movw	r24, r22
     87a:	66 81       	ldd	r22, Z+6	; 0x06
     87c:	77 81       	ldd	r23, Z+7	; 0x07
     87e:	0e 94 bf 0b 	call	0x177e	; 0x177e <memcpy>
     882:	08 95       	ret

00000884 <prvUnlockQueue>:
     884:	cf 93       	push	r28
     886:	df 93       	push	r29
     888:	ec 01       	movw	r28, r24
     88a:	0f b6       	in	r0, 0x3f	; 63
     88c:	f8 94       	cli
     88e:	0f 92       	push	r0
     890:	0d c0       	rjmp	.+26     	; 0x8ac <prvUnlockQueue+0x28>
     892:	89 89       	ldd	r24, Y+17	; 0x11
     894:	88 23       	and	r24, r24
     896:	69 f0       	breq	.+26     	; 0x8b2 <prvUnlockQueue+0x2e>
     898:	ce 01       	movw	r24, r28
     89a:	41 96       	adiw	r24, 0x11	; 17
     89c:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     8a0:	81 11       	cpse	r24, r1
     8a2:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <vTaskMissedYield>
     8a6:	8e 8d       	ldd	r24, Y+30	; 0x1e
     8a8:	81 50       	subi	r24, 0x01	; 1
     8aa:	8e 8f       	std	Y+30, r24	; 0x1e
     8ac:	8e 8d       	ldd	r24, Y+30	; 0x1e
     8ae:	18 16       	cp	r1, r24
     8b0:	84 f3       	brlt	.-32     	; 0x892 <prvUnlockQueue+0xe>
     8b2:	8f ef       	ldi	r24, 0xFF	; 255
     8b4:	8e 8f       	std	Y+30, r24	; 0x1e
     8b6:	0f 90       	pop	r0
     8b8:	0f be       	out	0x3f, r0	; 63
     8ba:	0f b6       	in	r0, 0x3f	; 63
     8bc:	f8 94       	cli
     8be:	0f 92       	push	r0
     8c0:	0d c0       	rjmp	.+26     	; 0x8dc <prvUnlockQueue+0x58>
     8c2:	88 85       	ldd	r24, Y+8	; 0x08
     8c4:	88 23       	and	r24, r24
     8c6:	69 f0       	breq	.+26     	; 0x8e2 <prvUnlockQueue+0x5e>
     8c8:	ce 01       	movw	r24, r28
     8ca:	08 96       	adiw	r24, 0x08	; 8
     8cc:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     8d0:	81 11       	cpse	r24, r1
     8d2:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <vTaskMissedYield>
     8d6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8d8:	81 50       	subi	r24, 0x01	; 1
     8da:	8d 8f       	std	Y+29, r24	; 0x1d
     8dc:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8de:	18 16       	cp	r1, r24
     8e0:	84 f3       	brlt	.-32     	; 0x8c2 <prvUnlockQueue+0x3e>
     8e2:	8f ef       	ldi	r24, 0xFF	; 255
     8e4:	8d 8f       	std	Y+29, r24	; 0x1d
     8e6:	0f 90       	pop	r0
     8e8:	0f be       	out	0x3f, r0	; 63
     8ea:	df 91       	pop	r29
     8ec:	cf 91       	pop	r28
     8ee:	08 95       	ret

000008f0 <xQueueGenericSend>:
     8f0:	cf 92       	push	r12
     8f2:	df 92       	push	r13
     8f4:	ef 92       	push	r14
     8f6:	ff 92       	push	r15
     8f8:	0f 93       	push	r16
     8fa:	1f 93       	push	r17
     8fc:	cf 93       	push	r28
     8fe:	df 93       	push	r29
     900:	00 d0       	rcall	.+0      	; 0x902 <xQueueGenericSend+0x12>
     902:	00 d0       	rcall	.+0      	; 0x904 <xQueueGenericSend+0x14>
     904:	1f 92       	push	r1
     906:	cd b7       	in	r28, 0x3d	; 61
     908:	de b7       	in	r29, 0x3e	; 62
     90a:	8c 01       	movw	r16, r24
     90c:	7b 01       	movw	r14, r22
     90e:	5d 83       	std	Y+5, r21	; 0x05
     910:	4c 83       	std	Y+4, r20	; 0x04
     912:	c2 2e       	mov	r12, r18
     914:	d1 2c       	mov	r13, r1
     916:	0f b6       	in	r0, 0x3f	; 63
     918:	f8 94       	cli
     91a:	0f 92       	push	r0
     91c:	f8 01       	movw	r30, r16
     91e:	92 8d       	ldd	r25, Z+26	; 0x1a
     920:	83 8d       	ldd	r24, Z+27	; 0x1b
     922:	98 17       	cp	r25, r24
     924:	18 f0       	brcs	.+6      	; 0x92c <xQueueGenericSend+0x3c>
     926:	f2 e0       	ldi	r31, 0x02	; 2
     928:	cf 12       	cpse	r12, r31
     92a:	19 c0       	rjmp	.+50     	; 0x95e <xQueueGenericSend+0x6e>
     92c:	4c 2d       	mov	r20, r12
     92e:	b7 01       	movw	r22, r14
     930:	c8 01       	movw	r24, r16
     932:	0e 94 c8 03 	call	0x790	; 0x790 <prvCopyDataToQueue>
     936:	f8 01       	movw	r30, r16
     938:	91 89       	ldd	r25, Z+17	; 0x11
     93a:	99 23       	and	r25, r25
     93c:	49 f0       	breq	.+18     	; 0x950 <xQueueGenericSend+0x60>
     93e:	c8 01       	movw	r24, r16
     940:	41 96       	adiw	r24, 0x11	; 17
     942:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     946:	81 30       	cpi	r24, 0x01	; 1
     948:	31 f4       	brne	.+12     	; 0x956 <xQueueGenericSend+0x66>
     94a:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vPortYield>
     94e:	03 c0       	rjmp	.+6      	; 0x956 <xQueueGenericSend+0x66>
     950:	81 11       	cpse	r24, r1
     952:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vPortYield>
     956:	0f 90       	pop	r0
     958:	0f be       	out	0x3f, r0	; 63
     95a:	81 e0       	ldi	r24, 0x01	; 1
     95c:	4d c0       	rjmp	.+154    	; 0x9f8 <xQueueGenericSend+0x108>
     95e:	8c 81       	ldd	r24, Y+4	; 0x04
     960:	9d 81       	ldd	r25, Y+5	; 0x05
     962:	89 2b       	or	r24, r25
     964:	21 f4       	brne	.+8      	; 0x96e <xQueueGenericSend+0x7e>
     966:	0f 90       	pop	r0
     968:	0f be       	out	0x3f, r0	; 63
     96a:	80 e0       	ldi	r24, 0x00	; 0
     96c:	45 c0       	rjmp	.+138    	; 0x9f8 <xQueueGenericSend+0x108>
     96e:	d1 10       	cpse	r13, r1
     970:	06 c0       	rjmp	.+12     	; 0x97e <xQueueGenericSend+0x8e>
     972:	ce 01       	movw	r24, r28
     974:	01 96       	adiw	r24, 0x01	; 1
     976:	0e 94 13 0a 	call	0x1426	; 0x1426 <vTaskSetTimeOutState>
     97a:	dd 24       	eor	r13, r13
     97c:	d3 94       	inc	r13
     97e:	0f 90       	pop	r0
     980:	0f be       	out	0x3f, r0	; 63
     982:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vTaskSuspendAll>
     986:	0f b6       	in	r0, 0x3f	; 63
     988:	f8 94       	cli
     98a:	0f 92       	push	r0
     98c:	f8 01       	movw	r30, r16
     98e:	85 8d       	ldd	r24, Z+29	; 0x1d
     990:	8f 3f       	cpi	r24, 0xFF	; 255
     992:	09 f4       	brne	.+2      	; 0x996 <xQueueGenericSend+0xa6>
     994:	15 8e       	std	Z+29, r1	; 0x1d
     996:	f8 01       	movw	r30, r16
     998:	86 8d       	ldd	r24, Z+30	; 0x1e
     99a:	8f 3f       	cpi	r24, 0xFF	; 255
     99c:	09 f4       	brne	.+2      	; 0x9a0 <xQueueGenericSend+0xb0>
     99e:	16 8e       	std	Z+30, r1	; 0x1e
     9a0:	0f 90       	pop	r0
     9a2:	0f be       	out	0x3f, r0	; 63
     9a4:	be 01       	movw	r22, r28
     9a6:	6c 5f       	subi	r22, 0xFC	; 252
     9a8:	7f 4f       	sbci	r23, 0xFF	; 255
     9aa:	ce 01       	movw	r24, r28
     9ac:	01 96       	adiw	r24, 0x01	; 1
     9ae:	0e 94 1e 0a 	call	0x143c	; 0x143c <xTaskCheckForTimeOut>
     9b2:	81 11       	cpse	r24, r1
     9b4:	1b c0       	rjmp	.+54     	; 0x9ec <xQueueGenericSend+0xfc>
     9b6:	c8 01       	movw	r24, r16
     9b8:	0e 94 ba 03 	call	0x774	; 0x774 <prvIsQueueFull>
     9bc:	88 23       	and	r24, r24
     9be:	81 f0       	breq	.+32     	; 0x9e0 <xQueueGenericSend+0xf0>
     9c0:	6c 81       	ldd	r22, Y+4	; 0x04
     9c2:	7d 81       	ldd	r23, Y+5	; 0x05
     9c4:	c8 01       	movw	r24, r16
     9c6:	08 96       	adiw	r24, 0x08	; 8
     9c8:	0e 94 ae 09 	call	0x135c	; 0x135c <vTaskPlaceOnEventList>
     9cc:	c8 01       	movw	r24, r16
     9ce:	0e 94 42 04 	call	0x884	; 0x884 <prvUnlockQueue>
     9d2:	0e 94 88 08 	call	0x1110	; 0x1110 <xTaskResumeAll>
     9d6:	81 11       	cpse	r24, r1
     9d8:	9e cf       	rjmp	.-196    	; 0x916 <xQueueGenericSend+0x26>
     9da:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vPortYield>
     9de:	9b cf       	rjmp	.-202    	; 0x916 <xQueueGenericSend+0x26>
     9e0:	c8 01       	movw	r24, r16
     9e2:	0e 94 42 04 	call	0x884	; 0x884 <prvUnlockQueue>
     9e6:	0e 94 88 08 	call	0x1110	; 0x1110 <xTaskResumeAll>
     9ea:	95 cf       	rjmp	.-214    	; 0x916 <xQueueGenericSend+0x26>
     9ec:	c8 01       	movw	r24, r16
     9ee:	0e 94 42 04 	call	0x884	; 0x884 <prvUnlockQueue>
     9f2:	0e 94 88 08 	call	0x1110	; 0x1110 <xTaskResumeAll>
     9f6:	80 e0       	ldi	r24, 0x00	; 0
     9f8:	0f 90       	pop	r0
     9fa:	0f 90       	pop	r0
     9fc:	0f 90       	pop	r0
     9fe:	0f 90       	pop	r0
     a00:	0f 90       	pop	r0
     a02:	df 91       	pop	r29
     a04:	cf 91       	pop	r28
     a06:	1f 91       	pop	r17
     a08:	0f 91       	pop	r16
     a0a:	ff 90       	pop	r15
     a0c:	ef 90       	pop	r14
     a0e:	df 90       	pop	r13
     a10:	cf 90       	pop	r12
     a12:	08 95       	ret

00000a14 <xQueueCreateMutex>:
     a14:	cf 93       	push	r28
     a16:	df 93       	push	r29
     a18:	8f e1       	ldi	r24, 0x1F	; 31
     a1a:	90 e0       	ldi	r25, 0x00	; 0
     a1c:	0e 94 91 01 	call	0x322	; 0x322 <pvPortMalloc>
     a20:	ec 01       	movw	r28, r24
     a22:	89 2b       	or	r24, r25
     a24:	f9 f0       	breq	.+62     	; 0xa64 <xQueueCreateMutex+0x50>
     a26:	1b 82       	std	Y+3, r1	; 0x03
     a28:	1a 82       	std	Y+2, r1	; 0x02
     a2a:	19 82       	std	Y+1, r1	; 0x01
     a2c:	18 82       	st	Y, r1
     a2e:	1d 82       	std	Y+5, r1	; 0x05
     a30:	1c 82       	std	Y+4, r1	; 0x04
     a32:	1f 82       	std	Y+7, r1	; 0x07
     a34:	1e 82       	std	Y+6, r1	; 0x06
     a36:	1a 8e       	std	Y+26, r1	; 0x1a
     a38:	81 e0       	ldi	r24, 0x01	; 1
     a3a:	8b 8f       	std	Y+27, r24	; 0x1b
     a3c:	1c 8e       	std	Y+28, r1	; 0x1c
     a3e:	8f ef       	ldi	r24, 0xFF	; 255
     a40:	8d 8f       	std	Y+29, r24	; 0x1d
     a42:	8e 8f       	std	Y+30, r24	; 0x1e
     a44:	ce 01       	movw	r24, r28
     a46:	08 96       	adiw	r24, 0x08	; 8
     a48:	0e 94 c7 01 	call	0x38e	; 0x38e <vListInitialise>
     a4c:	ce 01       	movw	r24, r28
     a4e:	41 96       	adiw	r24, 0x11	; 17
     a50:	0e 94 c7 01 	call	0x38e	; 0x38e <vListInitialise>
     a54:	20 e0       	ldi	r18, 0x00	; 0
     a56:	40 e0       	ldi	r20, 0x00	; 0
     a58:	50 e0       	ldi	r21, 0x00	; 0
     a5a:	60 e0       	ldi	r22, 0x00	; 0
     a5c:	70 e0       	ldi	r23, 0x00	; 0
     a5e:	ce 01       	movw	r24, r28
     a60:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xQueueGenericSend>
     a64:	ce 01       	movw	r24, r28
     a66:	df 91       	pop	r29
     a68:	cf 91       	pop	r28
     a6a:	08 95       	ret

00000a6c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     a6c:	af 92       	push	r10
     a6e:	bf 92       	push	r11
     a70:	cf 92       	push	r12
     a72:	df 92       	push	r13
     a74:	ef 92       	push	r14
     a76:	ff 92       	push	r15
     a78:	0f 93       	push	r16
     a7a:	1f 93       	push	r17
     a7c:	cf 93       	push	r28
     a7e:	df 93       	push	r29
     a80:	00 d0       	rcall	.+0      	; 0xa82 <xQueueGenericReceive+0x16>
     a82:	00 d0       	rcall	.+0      	; 0xa84 <xQueueGenericReceive+0x18>
     a84:	1f 92       	push	r1
     a86:	cd b7       	in	r28, 0x3d	; 61
     a88:	de b7       	in	r29, 0x3e	; 62
     a8a:	8c 01       	movw	r16, r24
     a8c:	6b 01       	movw	r12, r22
     a8e:	5d 83       	std	Y+5, r21	; 0x05
     a90:	4c 83       	std	Y+4, r20	; 0x04
     a92:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE;
     a94:	f1 2c       	mov	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     a96:	0f b6       	in	r0, 0x3f	; 63
     a98:	f8 94       	cli
     a9a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     a9c:	f8 01       	movw	r30, r16
     a9e:	82 8d       	ldd	r24, Z+26	; 0x1a
     aa0:	88 23       	and	r24, r24
     aa2:	99 f1       	breq	.+102    	; 0xb0a <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     aa4:	a6 80       	ldd	r10, Z+6	; 0x06
     aa6:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     aa8:	b6 01       	movw	r22, r12
     aaa:	c8 01       	movw	r24, r16
     aac:	0e 94 28 04 	call	0x850	; 0x850 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     ab0:	e1 10       	cpse	r14, r1
     ab2:	1a c0       	rjmp	.+52     	; 0xae8 <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     ab4:	f8 01       	movw	r30, r16
     ab6:	82 8d       	ldd	r24, Z+26	; 0x1a
     ab8:	81 50       	subi	r24, 0x01	; 1
     aba:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     abc:	80 81       	ld	r24, Z
     abe:	91 81       	ldd	r25, Z+1	; 0x01
     ac0:	89 2b       	or	r24, r25
     ac2:	29 f4       	brne	.+10     	; 0xace <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     ac4:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <pvTaskIncrementMutexHeldCount>
     ac8:	f8 01       	movw	r30, r16
     aca:	93 83       	std	Z+3, r25	; 0x03
     acc:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ace:	f8 01       	movw	r30, r16
     ad0:	80 85       	ldd	r24, Z+8	; 0x08
     ad2:	88 23       	and	r24, r24
     ad4:	b1 f0       	breq	.+44     	; 0xb02 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     ad6:	c8 01       	movw	r24, r16
     ad8:	08 96       	adiw	r24, 0x08	; 8
     ada:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     ade:	81 30       	cpi	r24, 0x01	; 1
     ae0:	81 f4       	brne	.+32     	; 0xb02 <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
     ae2:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vPortYield>
     ae6:	0d c0       	rjmp	.+26     	; 0xb02 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     ae8:	f8 01       	movw	r30, r16
     aea:	b7 82       	std	Z+7, r11	; 0x07
     aec:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     aee:	81 89       	ldd	r24, Z+17	; 0x11
     af0:	88 23       	and	r24, r24
     af2:	39 f0       	breq	.+14     	; 0xb02 <xQueueGenericReceive+0x96>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     af4:	c8 01       	movw	r24, r16
     af6:	41 96       	adiw	r24, 0x11	; 17
     af8:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     afc:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     afe:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     b02:	0f 90       	pop	r0
     b04:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     b06:	81 e0       	ldi	r24, 0x01	; 1
     b08:	5b c0       	rjmp	.+182    	; 0xbc0 <xQueueGenericReceive+0x154>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     b0a:	8c 81       	ldd	r24, Y+4	; 0x04
     b0c:	9d 81       	ldd	r25, Y+5	; 0x05
     b0e:	89 2b       	or	r24, r25
     b10:	21 f4       	brne	.+8      	; 0xb1a <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     b12:	0f 90       	pop	r0
     b14:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     b16:	80 e0       	ldi	r24, 0x00	; 0
     b18:	53 c0       	rjmp	.+166    	; 0xbc0 <xQueueGenericReceive+0x154>
				}
				else if( xEntryTimeSet == pdFALSE )
     b1a:	f1 10       	cpse	r15, r1
     b1c:	06 c0       	rjmp	.+12     	; 0xb2a <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     b1e:	ce 01       	movw	r24, r28
     b20:	01 96       	adiw	r24, 0x01	; 1
     b22:	0e 94 13 0a 	call	0x1426	; 0x1426 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     b26:	ff 24       	eor	r15, r15
     b28:	f3 94       	inc	r15
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     b2a:	0f 90       	pop	r0
     b2c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     b2e:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b32:	0f b6       	in	r0, 0x3f	; 63
     b34:	f8 94       	cli
     b36:	0f 92       	push	r0
     b38:	f8 01       	movw	r30, r16
     b3a:	85 8d       	ldd	r24, Z+29	; 0x1d
     b3c:	8f 3f       	cpi	r24, 0xFF	; 255
     b3e:	09 f4       	brne	.+2      	; 0xb42 <xQueueGenericReceive+0xd6>
     b40:	15 8e       	std	Z+29, r1	; 0x1d
     b42:	f8 01       	movw	r30, r16
     b44:	86 8d       	ldd	r24, Z+30	; 0x1e
     b46:	8f 3f       	cpi	r24, 0xFF	; 255
     b48:	09 f4       	brne	.+2      	; 0xb4c <xQueueGenericReceive+0xe0>
     b4a:	16 8e       	std	Z+30, r1	; 0x1e
     b4c:	0f 90       	pop	r0
     b4e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b50:	be 01       	movw	r22, r28
     b52:	6c 5f       	subi	r22, 0xFC	; 252
     b54:	7f 4f       	sbci	r23, 0xFF	; 255
     b56:	ce 01       	movw	r24, r28
     b58:	01 96       	adiw	r24, 0x01	; 1
     b5a:	0e 94 1e 0a 	call	0x143c	; 0x143c <xTaskCheckForTimeOut>
     b5e:	81 11       	cpse	r24, r1
     b60:	29 c0       	rjmp	.+82     	; 0xbb4 <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b62:	c8 01       	movw	r24, r16
     b64:	0e 94 ad 03 	call	0x75a	; 0x75a <prvIsQueueEmpty>
     b68:	88 23       	and	r24, r24
     b6a:	f1 f0       	breq	.+60     	; 0xba8 <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     b6c:	f8 01       	movw	r30, r16
     b6e:	80 81       	ld	r24, Z
     b70:	91 81       	ldd	r25, Z+1	; 0x01
     b72:	89 2b       	or	r24, r25
     b74:	49 f4       	brne	.+18     	; 0xb88 <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
     b76:	0f b6       	in	r0, 0x3f	; 63
     b78:	f8 94       	cli
     b7a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     b7c:	82 81       	ldd	r24, Z+2	; 0x02
     b7e:	93 81       	ldd	r25, Z+3	; 0x03
     b80:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     b84:	0f 90       	pop	r0
     b86:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b88:	6c 81       	ldd	r22, Y+4	; 0x04
     b8a:	7d 81       	ldd	r23, Y+5	; 0x05
     b8c:	c8 01       	movw	r24, r16
     b8e:	41 96       	adiw	r24, 0x11	; 17
     b90:	0e 94 ae 09 	call	0x135c	; 0x135c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     b94:	c8 01       	movw	r24, r16
     b96:	0e 94 42 04 	call	0x884	; 0x884 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     b9a:	0e 94 88 08 	call	0x1110	; 0x1110 <xTaskResumeAll>
     b9e:	81 11       	cpse	r24, r1
     ba0:	7a cf       	rjmp	.-268    	; 0xa96 <xQueueGenericReceive+0x2a>
				{
					portYIELD_WITHIN_API();
     ba2:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vPortYield>
     ba6:	77 cf       	rjmp	.-274    	; 0xa96 <xQueueGenericReceive+0x2a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     ba8:	c8 01       	movw	r24, r16
     baa:	0e 94 42 04 	call	0x884	; 0x884 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     bae:	0e 94 88 08 	call	0x1110	; 0x1110 <xTaskResumeAll>
     bb2:	71 cf       	rjmp	.-286    	; 0xa96 <xQueueGenericReceive+0x2a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     bb4:	c8 01       	movw	r24, r16
     bb6:	0e 94 42 04 	call	0x884	; 0x884 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     bba:	0e 94 88 08 	call	0x1110	; 0x1110 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     bbe:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     bc0:	0f 90       	pop	r0
     bc2:	0f 90       	pop	r0
     bc4:	0f 90       	pop	r0
     bc6:	0f 90       	pop	r0
     bc8:	0f 90       	pop	r0
     bca:	df 91       	pop	r29
     bcc:	cf 91       	pop	r28
     bce:	1f 91       	pop	r17
     bd0:	0f 91       	pop	r16
     bd2:	ff 90       	pop	r15
     bd4:	ef 90       	pop	r14
     bd6:	df 90       	pop	r13
     bd8:	cf 90       	pop	r12
     bda:	bf 90       	pop	r11
     bdc:	af 90       	pop	r10
     bde:	08 95       	ret

00000be0 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     be0:	e0 91 35 05 	lds	r30, 0x0535	; 0x800535 <pxDelayedTaskList>
     be4:	f0 91 36 05 	lds	r31, 0x0536	; 0x800536 <pxDelayedTaskList+0x1>
     be8:	80 81       	ld	r24, Z
     bea:	81 11       	cpse	r24, r1
     bec:	07 c0       	rjmp	.+14     	; 0xbfc <prvResetNextTaskUnblockTime+0x1c>
     bee:	8f ef       	ldi	r24, 0xFF	; 255
     bf0:	9f ef       	ldi	r25, 0xFF	; 255
     bf2:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     bf6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     bfa:	08 95       	ret
     bfc:	e0 91 35 05 	lds	r30, 0x0535	; 0x800535 <pxDelayedTaskList>
     c00:	f0 91 36 05 	lds	r31, 0x0536	; 0x800536 <pxDelayedTaskList+0x1>
     c04:	05 80       	ldd	r0, Z+5	; 0x05
     c06:	f6 81       	ldd	r31, Z+6	; 0x06
     c08:	e0 2d       	mov	r30, r0
     c0a:	06 80       	ldd	r0, Z+6	; 0x06
     c0c:	f7 81       	ldd	r31, Z+7	; 0x07
     c0e:	e0 2d       	mov	r30, r0
     c10:	82 81       	ldd	r24, Z+2	; 0x02
     c12:	93 81       	ldd	r25, Z+3	; 0x03
     c14:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     c18:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     c1c:	08 95       	ret

00000c1e <prvAllocateTCBAndStack>:
     c1e:	ef 92       	push	r14
     c20:	ff 92       	push	r15
     c22:	0f 93       	push	r16
     c24:	1f 93       	push	r17
     c26:	cf 93       	push	r28
     c28:	df 93       	push	r29
     c2a:	7c 01       	movw	r14, r24
     c2c:	eb 01       	movw	r28, r22
     c2e:	8f e2       	ldi	r24, 0x2F	; 47
     c30:	90 e0       	ldi	r25, 0x00	; 0
     c32:	0e 94 91 01 	call	0x322	; 0x322 <pvPortMalloc>
     c36:	8c 01       	movw	r16, r24
     c38:	89 2b       	or	r24, r25
     c3a:	89 f0       	breq	.+34     	; 0xc5e <prvAllocateTCBAndStack+0x40>
     c3c:	20 97       	sbiw	r28, 0x00	; 0
     c3e:	21 f4       	brne	.+8      	; 0xc48 <prvAllocateTCBAndStack+0x2a>
     c40:	c7 01       	movw	r24, r14
     c42:	0e 94 91 01 	call	0x322	; 0x322 <pvPortMalloc>
     c46:	01 c0       	rjmp	.+2      	; 0xc4a <prvAllocateTCBAndStack+0x2c>
     c48:	ce 01       	movw	r24, r28
     c4a:	f8 01       	movw	r30, r16
     c4c:	90 8f       	std	Z+24, r25	; 0x18
     c4e:	87 8b       	std	Z+23, r24	; 0x17
     c50:	89 2b       	or	r24, r25
     c52:	29 f4       	brne	.+10     	; 0xc5e <prvAllocateTCBAndStack+0x40>
     c54:	c8 01       	movw	r24, r16
     c56:	0e 94 c6 01 	call	0x38c	; 0x38c <vPortFree>
     c5a:	00 e0       	ldi	r16, 0x00	; 0
     c5c:	10 e0       	ldi	r17, 0x00	; 0
     c5e:	c8 01       	movw	r24, r16
     c60:	df 91       	pop	r29
     c62:	cf 91       	pop	r28
     c64:	1f 91       	pop	r17
     c66:	0f 91       	pop	r16
     c68:	ff 90       	pop	r15
     c6a:	ef 90       	pop	r14
     c6c:	08 95       	ret

00000c6e <prvDeleteTCB>:
     c6e:	cf 93       	push	r28
     c70:	df 93       	push	r29
     c72:	ec 01       	movw	r28, r24
     c74:	8f 89       	ldd	r24, Y+23	; 0x17
     c76:	98 8d       	ldd	r25, Y+24	; 0x18
     c78:	0e 94 c6 01 	call	0x38c	; 0x38c <vPortFree>
     c7c:	ce 01       	movw	r24, r28
     c7e:	0e 94 c6 01 	call	0x38c	; 0x38c <vPortFree>
     c82:	df 91       	pop	r29
     c84:	cf 91       	pop	r28
     c86:	08 95       	ret

00000c88 <prvInitialiseTCBVariables>:
     c88:	1f 93       	push	r17
     c8a:	cf 93       	push	r28
     c8c:	df 93       	push	r29
     c8e:	ec 01       	movw	r28, r24
     c90:	14 2f       	mov	r17, r20
     c92:	20 e0       	ldi	r18, 0x00	; 0
     c94:	0f c0       	rjmp	.+30     	; 0xcb4 <prvInitialiseTCBVariables+0x2c>
     c96:	82 2f       	mov	r24, r18
     c98:	90 e0       	ldi	r25, 0x00	; 0
     c9a:	fb 01       	movw	r30, r22
     c9c:	e8 0f       	add	r30, r24
     c9e:	f9 1f       	adc	r31, r25
     ca0:	30 81       	ld	r19, Z
     ca2:	de 01       	movw	r26, r28
     ca4:	a8 0f       	add	r26, r24
     ca6:	b9 1f       	adc	r27, r25
     ca8:	59 96       	adiw	r26, 0x19	; 25
     caa:	3c 93       	st	X, r19
     cac:	80 81       	ld	r24, Z
     cae:	88 23       	and	r24, r24
     cb0:	19 f0       	breq	.+6      	; 0xcb8 <prvInitialiseTCBVariables+0x30>
     cb2:	2f 5f       	subi	r18, 0xFF	; 255
     cb4:	24 31       	cpi	r18, 0x14	; 20
     cb6:	78 f3       	brcs	.-34     	; 0xc96 <prvInitialiseTCBVariables+0xe>
     cb8:	1c a6       	std	Y+44, r1	; 0x2c
     cba:	14 30       	cpi	r17, 0x04	; 4
     cbc:	08 f0       	brcs	.+2      	; 0xcc0 <prvInitialiseTCBVariables+0x38>
     cbe:	13 e0       	ldi	r17, 0x03	; 3
     cc0:	1e 8b       	std	Y+22, r17	; 0x16
     cc2:	1d a7       	std	Y+45, r17	; 0x2d
     cc4:	1e a6       	std	Y+46, r1	; 0x2e
     cc6:	ce 01       	movw	r24, r28
     cc8:	02 96       	adiw	r24, 0x02	; 2
     cca:	0e 94 d5 01 	call	0x3aa	; 0x3aa <vListInitialiseItem>
     cce:	ce 01       	movw	r24, r28
     cd0:	0c 96       	adiw	r24, 0x0c	; 12
     cd2:	0e 94 d5 01 	call	0x3aa	; 0x3aa <vListInitialiseItem>
     cd6:	d9 87       	std	Y+9, r29	; 0x09
     cd8:	c8 87       	std	Y+8, r28	; 0x08
     cda:	84 e0       	ldi	r24, 0x04	; 4
     cdc:	90 e0       	ldi	r25, 0x00	; 0
     cde:	81 1b       	sub	r24, r17
     ce0:	91 09       	sbc	r25, r1
     ce2:	9d 87       	std	Y+13, r25	; 0x0d
     ce4:	8c 87       	std	Y+12, r24	; 0x0c
     ce6:	db 8b       	std	Y+19, r29	; 0x13
     ce8:	ca 8b       	std	Y+18, r28	; 0x12
     cea:	df 91       	pop	r29
     cec:	cf 91       	pop	r28
     cee:	1f 91       	pop	r17
     cf0:	08 95       	ret

00000cf2 <prvInitialiseTaskLists>:
     cf2:	cf 93       	push	r28
     cf4:	c0 e0       	ldi	r28, 0x00	; 0
     cf6:	10 c0       	rjmp	.+32     	; 0xd18 <prvInitialiseTaskLists+0x26>
     cf8:	8c 2f       	mov	r24, r28
     cfa:	90 e0       	ldi	r25, 0x00	; 0
     cfc:	9c 01       	movw	r18, r24
     cfe:	22 0f       	add	r18, r18
     d00:	33 1f       	adc	r19, r19
     d02:	22 0f       	add	r18, r18
     d04:	33 1f       	adc	r19, r19
     d06:	22 0f       	add	r18, r18
     d08:	33 1f       	adc	r19, r19
     d0a:	82 0f       	add	r24, r18
     d0c:	93 1f       	adc	r25, r19
     d0e:	87 5b       	subi	r24, 0xB7	; 183
     d10:	9a 4f       	sbci	r25, 0xFA	; 250
     d12:	0e 94 c7 01 	call	0x38e	; 0x38e <vListInitialise>
     d16:	cf 5f       	subi	r28, 0xFF	; 255
     d18:	c4 30       	cpi	r28, 0x04	; 4
     d1a:	70 f3       	brcs	.-36     	; 0xcf8 <prvInitialiseTaskLists+0x6>
     d1c:	80 e4       	ldi	r24, 0x40	; 64
     d1e:	95 e0       	ldi	r25, 0x05	; 5
     d20:	0e 94 c7 01 	call	0x38e	; 0x38e <vListInitialise>
     d24:	87 e3       	ldi	r24, 0x37	; 55
     d26:	95 e0       	ldi	r25, 0x05	; 5
     d28:	0e 94 c7 01 	call	0x38e	; 0x38e <vListInitialise>
     d2c:	8a e2       	ldi	r24, 0x2A	; 42
     d2e:	95 e0       	ldi	r25, 0x05	; 5
     d30:	0e 94 c7 01 	call	0x38e	; 0x38e <vListInitialise>
     d34:	81 e2       	ldi	r24, 0x21	; 33
     d36:	95 e0       	ldi	r25, 0x05	; 5
     d38:	0e 94 c7 01 	call	0x38e	; 0x38e <vListInitialise>
     d3c:	80 e4       	ldi	r24, 0x40	; 64
     d3e:	95 e0       	ldi	r25, 0x05	; 5
     d40:	90 93 36 05 	sts	0x0536, r25	; 0x800536 <pxDelayedTaskList+0x1>
     d44:	80 93 35 05 	sts	0x0535, r24	; 0x800535 <pxDelayedTaskList>
     d48:	87 e3       	ldi	r24, 0x37	; 55
     d4a:	95 e0       	ldi	r25, 0x05	; 5
     d4c:	90 93 34 05 	sts	0x0534, r25	; 0x800534 <pxOverflowDelayedTaskList+0x1>
     d50:	80 93 33 05 	sts	0x0533, r24	; 0x800533 <pxOverflowDelayedTaskList>
     d54:	cf 91       	pop	r28
     d56:	08 95       	ret

00000d58 <prvAddCurrentTaskToDelayedList>:
     d58:	cf 93       	push	r28
     d5a:	df 93       	push	r29
     d5c:	ec 01       	movw	r28, r24
     d5e:	e0 91 6d 05 	lds	r30, 0x056D	; 0x80056d <pxCurrentTCB>
     d62:	f0 91 6e 05 	lds	r31, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
     d66:	93 83       	std	Z+3, r25	; 0x03
     d68:	82 83       	std	Z+2, r24	; 0x02
     d6a:	80 91 1d 05 	lds	r24, 0x051D	; 0x80051d <xTickCount>
     d6e:	90 91 1e 05 	lds	r25, 0x051E	; 0x80051e <xTickCount+0x1>
     d72:	c8 17       	cp	r28, r24
     d74:	d9 07       	cpc	r29, r25
     d76:	68 f4       	brcc	.+26     	; 0xd92 <prvAddCurrentTaskToDelayedList+0x3a>
     d78:	60 91 6d 05 	lds	r22, 0x056D	; 0x80056d <pxCurrentTCB>
     d7c:	70 91 6e 05 	lds	r23, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
     d80:	80 91 33 05 	lds	r24, 0x0533	; 0x800533 <pxOverflowDelayedTaskList>
     d84:	90 91 34 05 	lds	r25, 0x0534	; 0x800534 <pxOverflowDelayedTaskList+0x1>
     d88:	6e 5f       	subi	r22, 0xFE	; 254
     d8a:	7f 4f       	sbci	r23, 0xFF	; 255
     d8c:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <vListInsert>
     d90:	17 c0       	rjmp	.+46     	; 0xdc0 <prvAddCurrentTaskToDelayedList+0x68>
     d92:	60 91 6d 05 	lds	r22, 0x056D	; 0x80056d <pxCurrentTCB>
     d96:	70 91 6e 05 	lds	r23, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
     d9a:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <pxDelayedTaskList>
     d9e:	90 91 36 05 	lds	r25, 0x0536	; 0x800536 <pxDelayedTaskList+0x1>
     da2:	6e 5f       	subi	r22, 0xFE	; 254
     da4:	7f 4f       	sbci	r23, 0xFF	; 255
     da6:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <vListInsert>
     daa:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     dae:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     db2:	c8 17       	cp	r28, r24
     db4:	d9 07       	cpc	r29, r25
     db6:	20 f4       	brcc	.+8      	; 0xdc0 <prvAddCurrentTaskToDelayedList+0x68>
     db8:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     dbc:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__DATA_REGION_ORIGIN__>
     dc0:	df 91       	pop	r29
     dc2:	cf 91       	pop	r28
     dc4:	08 95       	ret

00000dc6 <xTaskGenericCreate>:
     dc6:	2f 92       	push	r2
     dc8:	3f 92       	push	r3
     dca:	4f 92       	push	r4
     dcc:	5f 92       	push	r5
     dce:	7f 92       	push	r7
     dd0:	8f 92       	push	r8
     dd2:	9f 92       	push	r9
     dd4:	af 92       	push	r10
     dd6:	bf 92       	push	r11
     dd8:	cf 92       	push	r12
     dda:	df 92       	push	r13
     ddc:	ef 92       	push	r14
     dde:	ff 92       	push	r15
     de0:	0f 93       	push	r16
     de2:	1f 93       	push	r17
     de4:	cf 93       	push	r28
     de6:	df 93       	push	r29
     de8:	00 d0       	rcall	.+0      	; 0xdea <xTaskGenericCreate+0x24>
     dea:	00 d0       	rcall	.+0      	; 0xdec <xTaskGenericCreate+0x26>
     dec:	cd b7       	in	r28, 0x3d	; 61
     dee:	de b7       	in	r29, 0x3e	; 62
     df0:	9a 83       	std	Y+2, r25	; 0x02
     df2:	89 83       	std	Y+1, r24	; 0x01
     df4:	4b 01       	movw	r8, r22
     df6:	5c 83       	std	Y+4, r21	; 0x04
     df8:	4b 83       	std	Y+3, r20	; 0x03
     dfa:	19 01       	movw	r2, r18
     dfc:	70 2e       	mov	r7, r16
     dfe:	b6 01       	movw	r22, r12
     e00:	25 01       	movw	r4, r10
     e02:	ca 01       	movw	r24, r20
     e04:	0e 94 0f 06 	call	0xc1e	; 0xc1e <prvAllocateTCBAndStack>
     e08:	5c 01       	movw	r10, r24
     e0a:	00 97       	sbiw	r24, 0x00	; 0
     e0c:	09 f4       	brne	.+2      	; 0xe10 <xTaskGenericCreate+0x4a>
     e0e:	6a c0       	rjmp	.+212    	; 0xee4 <xTaskGenericCreate+0x11e>
     e10:	fc 01       	movw	r30, r24
     e12:	c7 88       	ldd	r12, Z+23	; 0x17
     e14:	d0 8c       	ldd	r13, Z+24	; 0x18
     e16:	8b 81       	ldd	r24, Y+3	; 0x03
     e18:	9c 81       	ldd	r25, Y+4	; 0x04
     e1a:	01 97       	sbiw	r24, 0x01	; 1
     e1c:	c8 0e       	add	r12, r24
     e1e:	d9 1e       	adc	r13, r25
     e20:	0b 81       	ldd	r16, Y+3	; 0x03
     e22:	1c 81       	ldd	r17, Y+4	; 0x04
     e24:	92 01       	movw	r18, r4
     e26:	47 2d       	mov	r20, r7
     e28:	b4 01       	movw	r22, r8
     e2a:	c5 01       	movw	r24, r10
     e2c:	0e 94 44 06 	call	0xc88	; 0xc88 <prvInitialiseTCBVariables>
     e30:	a1 01       	movw	r20, r2
     e32:	69 81       	ldd	r22, Y+1	; 0x01
     e34:	7a 81       	ldd	r23, Y+2	; 0x02
     e36:	c6 01       	movw	r24, r12
     e38:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <pxPortInitialiseStack>
     e3c:	f5 01       	movw	r30, r10
     e3e:	91 83       	std	Z+1, r25	; 0x01
     e40:	80 83       	st	Z, r24
     e42:	e1 14       	cp	r14, r1
     e44:	f1 04       	cpc	r15, r1
     e46:	19 f0       	breq	.+6      	; 0xe4e <xTaskGenericCreate+0x88>
     e48:	f7 01       	movw	r30, r14
     e4a:	b1 82       	std	Z+1, r11	; 0x01
     e4c:	a0 82       	st	Z, r10
     e4e:	0f b6       	in	r0, 0x3f	; 63
     e50:	f8 94       	cli
     e52:	0f 92       	push	r0
     e54:	80 91 1f 05 	lds	r24, 0x051F	; 0x80051f <uxCurrentNumberOfTasks>
     e58:	8f 5f       	subi	r24, 0xFF	; 255
     e5a:	80 93 1f 05 	sts	0x051F, r24	; 0x80051f <uxCurrentNumberOfTasks>
     e5e:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <pxCurrentTCB>
     e62:	90 91 6e 05 	lds	r25, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
     e66:	89 2b       	or	r24, r25
     e68:	59 f4       	brne	.+22     	; 0xe80 <xTaskGenericCreate+0xba>
     e6a:	b0 92 6e 05 	sts	0x056E, r11	; 0x80056e <pxCurrentTCB+0x1>
     e6e:	a0 92 6d 05 	sts	0x056D, r10	; 0x80056d <pxCurrentTCB>
     e72:	80 91 1f 05 	lds	r24, 0x051F	; 0x80051f <uxCurrentNumberOfTasks>
     e76:	81 30       	cpi	r24, 0x01	; 1
     e78:	91 f4       	brne	.+36     	; 0xe9e <xTaskGenericCreate+0xd8>
     e7a:	0e 94 79 06 	call	0xcf2	; 0xcf2 <prvInitialiseTaskLists>
     e7e:	0f c0       	rjmp	.+30     	; 0xe9e <xTaskGenericCreate+0xd8>
     e80:	80 91 1b 05 	lds	r24, 0x051B	; 0x80051b <xSchedulerRunning>
     e84:	81 11       	cpse	r24, r1
     e86:	0b c0       	rjmp	.+22     	; 0xe9e <xTaskGenericCreate+0xd8>
     e88:	e0 91 6d 05 	lds	r30, 0x056D	; 0x80056d <pxCurrentTCB>
     e8c:	f0 91 6e 05 	lds	r31, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
     e90:	86 89       	ldd	r24, Z+22	; 0x16
     e92:	78 16       	cp	r7, r24
     e94:	20 f0       	brcs	.+8      	; 0xe9e <xTaskGenericCreate+0xd8>
     e96:	b0 92 6e 05 	sts	0x056E, r11	; 0x80056e <pxCurrentTCB+0x1>
     e9a:	a0 92 6d 05 	sts	0x056D, r10	; 0x80056d <pxCurrentTCB>
     e9e:	80 91 17 05 	lds	r24, 0x0517	; 0x800517 <uxTaskNumber>
     ea2:	8f 5f       	subi	r24, 0xFF	; 255
     ea4:	80 93 17 05 	sts	0x0517, r24	; 0x800517 <uxTaskNumber>
     ea8:	f5 01       	movw	r30, r10
     eaa:	86 89       	ldd	r24, Z+22	; 0x16
     eac:	90 91 1c 05 	lds	r25, 0x051C	; 0x80051c <uxTopReadyPriority>
     eb0:	98 17       	cp	r25, r24
     eb2:	10 f4       	brcc	.+4      	; 0xeb8 <xTaskGenericCreate+0xf2>
     eb4:	80 93 1c 05 	sts	0x051C, r24	; 0x80051c <uxTopReadyPriority>
     eb8:	90 e0       	ldi	r25, 0x00	; 0
     eba:	b5 01       	movw	r22, r10
     ebc:	6e 5f       	subi	r22, 0xFE	; 254
     ebe:	7f 4f       	sbci	r23, 0xFF	; 255
     ec0:	9c 01       	movw	r18, r24
     ec2:	22 0f       	add	r18, r18
     ec4:	33 1f       	adc	r19, r19
     ec6:	22 0f       	add	r18, r18
     ec8:	33 1f       	adc	r19, r19
     eca:	22 0f       	add	r18, r18
     ecc:	33 1f       	adc	r19, r19
     ece:	82 0f       	add	r24, r18
     ed0:	93 1f       	adc	r25, r19
     ed2:	87 5b       	subi	r24, 0xB7	; 183
     ed4:	9a 4f       	sbci	r25, 0xFA	; 250
     ed6:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vListInsertEnd>
     eda:	0f 90       	pop	r0
     edc:	0f be       	out	0x3f, r0	; 63
     ede:	f1 e0       	ldi	r31, 0x01	; 1
     ee0:	f9 83       	std	Y+1, r31	; 0x01
     ee2:	02 c0       	rjmp	.+4      	; 0xee8 <xTaskGenericCreate+0x122>
     ee4:	8f ef       	ldi	r24, 0xFF	; 255
     ee6:	89 83       	std	Y+1, r24	; 0x01
     ee8:	e9 81       	ldd	r30, Y+1	; 0x01
     eea:	e1 30       	cpi	r30, 0x01	; 1
     eec:	69 f4       	brne	.+26     	; 0xf08 <xTaskGenericCreate+0x142>
     eee:	80 91 1b 05 	lds	r24, 0x051B	; 0x80051b <xSchedulerRunning>
     ef2:	88 23       	and	r24, r24
     ef4:	49 f0       	breq	.+18     	; 0xf08 <xTaskGenericCreate+0x142>
     ef6:	e0 91 6d 05 	lds	r30, 0x056D	; 0x80056d <pxCurrentTCB>
     efa:	f0 91 6e 05 	lds	r31, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
     efe:	86 89       	ldd	r24, Z+22	; 0x16
     f00:	87 15       	cp	r24, r7
     f02:	10 f4       	brcc	.+4      	; 0xf08 <xTaskGenericCreate+0x142>
     f04:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vPortYield>
     f08:	89 81       	ldd	r24, Y+1	; 0x01
     f0a:	0f 90       	pop	r0
     f0c:	0f 90       	pop	r0
     f0e:	0f 90       	pop	r0
     f10:	0f 90       	pop	r0
     f12:	df 91       	pop	r29
     f14:	cf 91       	pop	r28
     f16:	1f 91       	pop	r17
     f18:	0f 91       	pop	r16
     f1a:	ff 90       	pop	r15
     f1c:	ef 90       	pop	r14
     f1e:	df 90       	pop	r13
     f20:	cf 90       	pop	r12
     f22:	bf 90       	pop	r11
     f24:	af 90       	pop	r10
     f26:	9f 90       	pop	r9
     f28:	8f 90       	pop	r8
     f2a:	7f 90       	pop	r7
     f2c:	5f 90       	pop	r5
     f2e:	4f 90       	pop	r4
     f30:	3f 90       	pop	r3
     f32:	2f 90       	pop	r2
     f34:	08 95       	ret

00000f36 <vTaskStartScheduler>:
     f36:	af 92       	push	r10
     f38:	bf 92       	push	r11
     f3a:	cf 92       	push	r12
     f3c:	df 92       	push	r13
     f3e:	ef 92       	push	r14
     f40:	ff 92       	push	r15
     f42:	0f 93       	push	r16
     f44:	a1 2c       	mov	r10, r1
     f46:	b1 2c       	mov	r11, r1
     f48:	c1 2c       	mov	r12, r1
     f4a:	d1 2c       	mov	r13, r1
     f4c:	e1 2c       	mov	r14, r1
     f4e:	f1 2c       	mov	r15, r1
     f50:	00 e0       	ldi	r16, 0x00	; 0
     f52:	20 e0       	ldi	r18, 0x00	; 0
     f54:	30 e0       	ldi	r19, 0x00	; 0
     f56:	45 e5       	ldi	r20, 0x55	; 85
     f58:	50 e0       	ldi	r21, 0x00	; 0
     f5a:	62 e6       	ldi	r22, 0x62	; 98
     f5c:	70 e0       	ldi	r23, 0x00	; 0
     f5e:	89 e4       	ldi	r24, 0x49	; 73
     f60:	99 e0       	ldi	r25, 0x09	; 9
     f62:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <xTaskGenericCreate>
     f66:	81 30       	cpi	r24, 0x01	; 1
     f68:	49 f4       	brne	.+18     	; 0xf7c <vTaskStartScheduler+0x46>
     f6a:	f8 94       	cli
     f6c:	80 93 1b 05 	sts	0x051B, r24	; 0x80051b <xSchedulerRunning>
     f70:	10 92 1e 05 	sts	0x051E, r1	; 0x80051e <xTickCount+0x1>
     f74:	10 92 1d 05 	sts	0x051D, r1	; 0x80051d <xTickCount>
     f78:	0e 94 c6 02 	call	0x58c	; 0x58c <xPortStartScheduler>
     f7c:	0f 91       	pop	r16
     f7e:	ff 90       	pop	r15
     f80:	ef 90       	pop	r14
     f82:	df 90       	pop	r13
     f84:	cf 90       	pop	r12
     f86:	bf 90       	pop	r11
     f88:	af 90       	pop	r10
     f8a:	08 95       	ret

00000f8c <vTaskSuspendAll>:
     f8c:	80 91 16 05 	lds	r24, 0x0516	; 0x800516 <uxSchedulerSuspended>
     f90:	8f 5f       	subi	r24, 0xFF	; 255
     f92:	80 93 16 05 	sts	0x0516, r24	; 0x800516 <uxSchedulerSuspended>
     f96:	08 95       	ret

00000f98 <xTaskIncrementTick>:
     f98:	df 92       	push	r13
     f9a:	ef 92       	push	r14
     f9c:	ff 92       	push	r15
     f9e:	0f 93       	push	r16
     fa0:	1f 93       	push	r17
     fa2:	cf 93       	push	r28
     fa4:	df 93       	push	r29
     fa6:	80 91 16 05 	lds	r24, 0x0516	; 0x800516 <uxSchedulerSuspended>
     faa:	81 11       	cpse	r24, r1
     fac:	99 c0       	rjmp	.+306    	; 0x10e0 <xTaskIncrementTick+0x148>
     fae:	80 91 1d 05 	lds	r24, 0x051D	; 0x80051d <xTickCount>
     fb2:	90 91 1e 05 	lds	r25, 0x051E	; 0x80051e <xTickCount+0x1>
     fb6:	01 96       	adiw	r24, 0x01	; 1
     fb8:	90 93 1e 05 	sts	0x051E, r25	; 0x80051e <xTickCount+0x1>
     fbc:	80 93 1d 05 	sts	0x051D, r24	; 0x80051d <xTickCount>
     fc0:	e0 90 1d 05 	lds	r14, 0x051D	; 0x80051d <xTickCount>
     fc4:	f0 90 1e 05 	lds	r15, 0x051E	; 0x80051e <xTickCount+0x1>
     fc8:	e1 14       	cp	r14, r1
     fca:	f1 04       	cpc	r15, r1
     fcc:	b9 f4       	brne	.+46     	; 0xffc <xTaskIncrementTick+0x64>
     fce:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <pxDelayedTaskList>
     fd2:	90 91 36 05 	lds	r25, 0x0536	; 0x800536 <pxDelayedTaskList+0x1>
     fd6:	20 91 33 05 	lds	r18, 0x0533	; 0x800533 <pxOverflowDelayedTaskList>
     fda:	30 91 34 05 	lds	r19, 0x0534	; 0x800534 <pxOverflowDelayedTaskList+0x1>
     fde:	30 93 36 05 	sts	0x0536, r19	; 0x800536 <pxDelayedTaskList+0x1>
     fe2:	20 93 35 05 	sts	0x0535, r18	; 0x800535 <pxDelayedTaskList>
     fe6:	90 93 34 05 	sts	0x0534, r25	; 0x800534 <pxOverflowDelayedTaskList+0x1>
     fea:	80 93 33 05 	sts	0x0533, r24	; 0x800533 <pxOverflowDelayedTaskList>
     fee:	80 91 18 05 	lds	r24, 0x0518	; 0x800518 <xNumOfOverflows>
     ff2:	8f 5f       	subi	r24, 0xFF	; 255
     ff4:	80 93 18 05 	sts	0x0518, r24	; 0x800518 <xNumOfOverflows>
     ff8:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <prvResetNextTaskUnblockTime>
     ffc:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    1000:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    1004:	e8 16       	cp	r14, r24
    1006:	f9 06       	cpc	r15, r25
    1008:	28 f4       	brcc	.+10     	; 0x1014 <xTaskIncrementTick+0x7c>
    100a:	d1 2c       	mov	r13, r1
    100c:	53 c0       	rjmp	.+166    	; 0x10b4 <xTaskIncrementTick+0x11c>
    100e:	dd 24       	eor	r13, r13
    1010:	d3 94       	inc	r13
    1012:	01 c0       	rjmp	.+2      	; 0x1016 <xTaskIncrementTick+0x7e>
    1014:	d1 2c       	mov	r13, r1
    1016:	e0 91 35 05 	lds	r30, 0x0535	; 0x800535 <pxDelayedTaskList>
    101a:	f0 91 36 05 	lds	r31, 0x0536	; 0x800536 <pxDelayedTaskList+0x1>
    101e:	80 81       	ld	r24, Z
    1020:	81 11       	cpse	r24, r1
    1022:	07 c0       	rjmp	.+14     	; 0x1032 <xTaskIncrementTick+0x9a>
    1024:	8f ef       	ldi	r24, 0xFF	; 255
    1026:	9f ef       	ldi	r25, 0xFF	; 255
    1028:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    102c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    1030:	41 c0       	rjmp	.+130    	; 0x10b4 <xTaskIncrementTick+0x11c>
    1032:	e0 91 35 05 	lds	r30, 0x0535	; 0x800535 <pxDelayedTaskList>
    1036:	f0 91 36 05 	lds	r31, 0x0536	; 0x800536 <pxDelayedTaskList+0x1>
    103a:	05 80       	ldd	r0, Z+5	; 0x05
    103c:	f6 81       	ldd	r31, Z+6	; 0x06
    103e:	e0 2d       	mov	r30, r0
    1040:	c6 81       	ldd	r28, Z+6	; 0x06
    1042:	d7 81       	ldd	r29, Z+7	; 0x07
    1044:	8a 81       	ldd	r24, Y+2	; 0x02
    1046:	9b 81       	ldd	r25, Y+3	; 0x03
    1048:	e8 16       	cp	r14, r24
    104a:	f9 06       	cpc	r15, r25
    104c:	28 f4       	brcc	.+10     	; 0x1058 <xTaskIncrementTick+0xc0>
    104e:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    1052:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    1056:	2e c0       	rjmp	.+92     	; 0x10b4 <xTaskIncrementTick+0x11c>
    1058:	8e 01       	movw	r16, r28
    105a:	0e 5f       	subi	r16, 0xFE	; 254
    105c:	1f 4f       	sbci	r17, 0xFF	; 255
    105e:	c8 01       	movw	r24, r16
    1060:	0e 94 2b 02 	call	0x456	; 0x456 <uxListRemove>
    1064:	8c 89       	ldd	r24, Y+20	; 0x14
    1066:	9d 89       	ldd	r25, Y+21	; 0x15
    1068:	89 2b       	or	r24, r25
    106a:	21 f0       	breq	.+8      	; 0x1074 <xTaskIncrementTick+0xdc>
    106c:	ce 01       	movw	r24, r28
    106e:	0c 96       	adiw	r24, 0x0c	; 12
    1070:	0e 94 2b 02 	call	0x456	; 0x456 <uxListRemove>
    1074:	8e 89       	ldd	r24, Y+22	; 0x16
    1076:	90 91 1c 05 	lds	r25, 0x051C	; 0x80051c <uxTopReadyPriority>
    107a:	98 17       	cp	r25, r24
    107c:	10 f4       	brcc	.+4      	; 0x1082 <xTaskIncrementTick+0xea>
    107e:	80 93 1c 05 	sts	0x051C, r24	; 0x80051c <uxTopReadyPriority>
    1082:	90 e0       	ldi	r25, 0x00	; 0
    1084:	9c 01       	movw	r18, r24
    1086:	22 0f       	add	r18, r18
    1088:	33 1f       	adc	r19, r19
    108a:	22 0f       	add	r18, r18
    108c:	33 1f       	adc	r19, r19
    108e:	22 0f       	add	r18, r18
    1090:	33 1f       	adc	r19, r19
    1092:	82 0f       	add	r24, r18
    1094:	93 1f       	adc	r25, r19
    1096:	b8 01       	movw	r22, r16
    1098:	87 5b       	subi	r24, 0xB7	; 183
    109a:	9a 4f       	sbci	r25, 0xFA	; 250
    109c:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vListInsertEnd>
    10a0:	9e 89       	ldd	r25, Y+22	; 0x16
    10a2:	e0 91 6d 05 	lds	r30, 0x056D	; 0x80056d <pxCurrentTCB>
    10a6:	f0 91 6e 05 	lds	r31, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
    10aa:	86 89       	ldd	r24, Z+22	; 0x16
    10ac:	98 17       	cp	r25, r24
    10ae:	08 f0       	brcs	.+2      	; 0x10b2 <xTaskIncrementTick+0x11a>
    10b0:	ae cf       	rjmp	.-164    	; 0x100e <xTaskIncrementTick+0x76>
    10b2:	b1 cf       	rjmp	.-158    	; 0x1016 <xTaskIncrementTick+0x7e>
    10b4:	e0 91 6d 05 	lds	r30, 0x056D	; 0x80056d <pxCurrentTCB>
    10b8:	f0 91 6e 05 	lds	r31, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
    10bc:	86 89       	ldd	r24, Z+22	; 0x16
    10be:	90 e0       	ldi	r25, 0x00	; 0
    10c0:	fc 01       	movw	r30, r24
    10c2:	ee 0f       	add	r30, r30
    10c4:	ff 1f       	adc	r31, r31
    10c6:	ee 0f       	add	r30, r30
    10c8:	ff 1f       	adc	r31, r31
    10ca:	ee 0f       	add	r30, r30
    10cc:	ff 1f       	adc	r31, r31
    10ce:	8e 0f       	add	r24, r30
    10d0:	9f 1f       	adc	r25, r31
    10d2:	fc 01       	movw	r30, r24
    10d4:	e7 5b       	subi	r30, 0xB7	; 183
    10d6:	fa 4f       	sbci	r31, 0xFA	; 250
    10d8:	80 81       	ld	r24, Z
    10da:	82 30       	cpi	r24, 0x02	; 2
    10dc:	40 f4       	brcc	.+16     	; 0x10ee <xTaskIncrementTick+0x156>
    10de:	09 c0       	rjmp	.+18     	; 0x10f2 <xTaskIncrementTick+0x15a>
    10e0:	80 91 1a 05 	lds	r24, 0x051A	; 0x80051a <uxPendedTicks>
    10e4:	8f 5f       	subi	r24, 0xFF	; 255
    10e6:	80 93 1a 05 	sts	0x051A, r24	; 0x80051a <uxPendedTicks>
    10ea:	d1 2c       	mov	r13, r1
    10ec:	02 c0       	rjmp	.+4      	; 0x10f2 <xTaskIncrementTick+0x15a>
    10ee:	dd 24       	eor	r13, r13
    10f0:	d3 94       	inc	r13
    10f2:	80 91 19 05 	lds	r24, 0x0519	; 0x800519 <xYieldPending>
    10f6:	88 23       	and	r24, r24
    10f8:	11 f0       	breq	.+4      	; 0x10fe <xTaskIncrementTick+0x166>
    10fa:	dd 24       	eor	r13, r13
    10fc:	d3 94       	inc	r13
    10fe:	8d 2d       	mov	r24, r13
    1100:	df 91       	pop	r29
    1102:	cf 91       	pop	r28
    1104:	1f 91       	pop	r17
    1106:	0f 91       	pop	r16
    1108:	ff 90       	pop	r15
    110a:	ef 90       	pop	r14
    110c:	df 90       	pop	r13
    110e:	08 95       	ret

00001110 <xTaskResumeAll>:
    1110:	0f 93       	push	r16
    1112:	1f 93       	push	r17
    1114:	cf 93       	push	r28
    1116:	df 93       	push	r29
    1118:	0f b6       	in	r0, 0x3f	; 63
    111a:	f8 94       	cli
    111c:	0f 92       	push	r0
    111e:	80 91 16 05 	lds	r24, 0x0516	; 0x800516 <uxSchedulerSuspended>
    1122:	81 50       	subi	r24, 0x01	; 1
    1124:	80 93 16 05 	sts	0x0516, r24	; 0x800516 <uxSchedulerSuspended>
    1128:	80 91 16 05 	lds	r24, 0x0516	; 0x800516 <uxSchedulerSuspended>
    112c:	81 11       	cpse	r24, r1
    112e:	57 c0       	rjmp	.+174    	; 0x11de <xTaskResumeAll+0xce>
    1130:	80 91 1f 05 	lds	r24, 0x051F	; 0x80051f <uxCurrentNumberOfTasks>
    1134:	81 11       	cpse	r24, r1
    1136:	32 c0       	rjmp	.+100    	; 0x119c <xTaskResumeAll+0x8c>
    1138:	55 c0       	rjmp	.+170    	; 0x11e4 <xTaskResumeAll+0xd4>
    113a:	e0 91 2f 05 	lds	r30, 0x052F	; 0x80052f <xPendingReadyList+0x5>
    113e:	f0 91 30 05 	lds	r31, 0x0530	; 0x800530 <xPendingReadyList+0x6>
    1142:	c6 81       	ldd	r28, Z+6	; 0x06
    1144:	d7 81       	ldd	r29, Z+7	; 0x07
    1146:	ce 01       	movw	r24, r28
    1148:	0c 96       	adiw	r24, 0x0c	; 12
    114a:	0e 94 2b 02 	call	0x456	; 0x456 <uxListRemove>
    114e:	8e 01       	movw	r16, r28
    1150:	0e 5f       	subi	r16, 0xFE	; 254
    1152:	1f 4f       	sbci	r17, 0xFF	; 255
    1154:	c8 01       	movw	r24, r16
    1156:	0e 94 2b 02 	call	0x456	; 0x456 <uxListRemove>
    115a:	8e 89       	ldd	r24, Y+22	; 0x16
    115c:	90 91 1c 05 	lds	r25, 0x051C	; 0x80051c <uxTopReadyPriority>
    1160:	98 17       	cp	r25, r24
    1162:	10 f4       	brcc	.+4      	; 0x1168 <xTaskResumeAll+0x58>
    1164:	80 93 1c 05 	sts	0x051C, r24	; 0x80051c <uxTopReadyPriority>
    1168:	90 e0       	ldi	r25, 0x00	; 0
    116a:	9c 01       	movw	r18, r24
    116c:	22 0f       	add	r18, r18
    116e:	33 1f       	adc	r19, r19
    1170:	22 0f       	add	r18, r18
    1172:	33 1f       	adc	r19, r19
    1174:	22 0f       	add	r18, r18
    1176:	33 1f       	adc	r19, r19
    1178:	82 0f       	add	r24, r18
    117a:	93 1f       	adc	r25, r19
    117c:	b8 01       	movw	r22, r16
    117e:	87 5b       	subi	r24, 0xB7	; 183
    1180:	9a 4f       	sbci	r25, 0xFA	; 250
    1182:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vListInsertEnd>
    1186:	9e 89       	ldd	r25, Y+22	; 0x16
    1188:	e0 91 6d 05 	lds	r30, 0x056D	; 0x80056d <pxCurrentTCB>
    118c:	f0 91 6e 05 	lds	r31, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
    1190:	86 89       	ldd	r24, Z+22	; 0x16
    1192:	98 17       	cp	r25, r24
    1194:	18 f0       	brcs	.+6      	; 0x119c <xTaskResumeAll+0x8c>
    1196:	81 e0       	ldi	r24, 0x01	; 1
    1198:	80 93 19 05 	sts	0x0519, r24	; 0x800519 <xYieldPending>
    119c:	80 91 2a 05 	lds	r24, 0x052A	; 0x80052a <xPendingReadyList>
    11a0:	81 11       	cpse	r24, r1
    11a2:	cb cf       	rjmp	.-106    	; 0x113a <xTaskResumeAll+0x2a>
    11a4:	80 91 1a 05 	lds	r24, 0x051A	; 0x80051a <uxPendedTicks>
    11a8:	81 11       	cpse	r24, r1
    11aa:	0d c0       	rjmp	.+26     	; 0x11c6 <xTaskResumeAll+0xb6>
    11ac:	10 c0       	rjmp	.+32     	; 0x11ce <xTaskResumeAll+0xbe>
    11ae:	0e 94 cc 07 	call	0xf98	; 0xf98 <xTaskIncrementTick>
    11b2:	88 23       	and	r24, r24
    11b4:	19 f0       	breq	.+6      	; 0x11bc <xTaskResumeAll+0xac>
    11b6:	81 e0       	ldi	r24, 0x01	; 1
    11b8:	80 93 19 05 	sts	0x0519, r24	; 0x800519 <xYieldPending>
    11bc:	80 91 1a 05 	lds	r24, 0x051A	; 0x80051a <uxPendedTicks>
    11c0:	81 50       	subi	r24, 0x01	; 1
    11c2:	80 93 1a 05 	sts	0x051A, r24	; 0x80051a <uxPendedTicks>
    11c6:	80 91 1a 05 	lds	r24, 0x051A	; 0x80051a <uxPendedTicks>
    11ca:	81 11       	cpse	r24, r1
    11cc:	f0 cf       	rjmp	.-32     	; 0x11ae <xTaskResumeAll+0x9e>
    11ce:	80 91 19 05 	lds	r24, 0x0519	; 0x800519 <xYieldPending>
    11d2:	81 30       	cpi	r24, 0x01	; 1
    11d4:	31 f4       	brne	.+12     	; 0x11e2 <xTaskResumeAll+0xd2>
    11d6:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vPortYield>
    11da:	81 e0       	ldi	r24, 0x01	; 1
    11dc:	03 c0       	rjmp	.+6      	; 0x11e4 <xTaskResumeAll+0xd4>
    11de:	80 e0       	ldi	r24, 0x00	; 0
    11e0:	01 c0       	rjmp	.+2      	; 0x11e4 <xTaskResumeAll+0xd4>
    11e2:	80 e0       	ldi	r24, 0x00	; 0
    11e4:	0f 90       	pop	r0
    11e6:	0f be       	out	0x3f, r0	; 63
    11e8:	df 91       	pop	r29
    11ea:	cf 91       	pop	r28
    11ec:	1f 91       	pop	r17
    11ee:	0f 91       	pop	r16
    11f0:	08 95       	ret

000011f2 <vTaskDelay>:
    11f2:	cf 93       	push	r28
    11f4:	df 93       	push	r29
    11f6:	ec 01       	movw	r28, r24
    11f8:	89 2b       	or	r24, r25
    11fa:	a9 f0       	breq	.+42     	; 0x1226 <vTaskDelay+0x34>
    11fc:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vTaskSuspendAll>
    1200:	80 91 1d 05 	lds	r24, 0x051D	; 0x80051d <xTickCount>
    1204:	90 91 1e 05 	lds	r25, 0x051E	; 0x80051e <xTickCount+0x1>
    1208:	c8 0f       	add	r28, r24
    120a:	d9 1f       	adc	r29, r25
    120c:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <pxCurrentTCB>
    1210:	90 91 6e 05 	lds	r25, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
    1214:	02 96       	adiw	r24, 0x02	; 2
    1216:	0e 94 2b 02 	call	0x456	; 0x456 <uxListRemove>
    121a:	ce 01       	movw	r24, r28
    121c:	0e 94 ac 06 	call	0xd58	; 0xd58 <prvAddCurrentTaskToDelayedList>
    1220:	0e 94 88 08 	call	0x1110	; 0x1110 <xTaskResumeAll>
    1224:	01 c0       	rjmp	.+2      	; 0x1228 <vTaskDelay+0x36>
    1226:	80 e0       	ldi	r24, 0x00	; 0
    1228:	81 11       	cpse	r24, r1
    122a:	02 c0       	rjmp	.+4      	; 0x1230 <vTaskDelay+0x3e>
    122c:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vPortYield>
    1230:	df 91       	pop	r29
    1232:	cf 91       	pop	r28
    1234:	08 95       	ret

00001236 <prvCheckTasksWaitingTermination>:
    1236:	cf 93       	push	r28
    1238:	df 93       	push	r29
    123a:	24 c0       	rjmp	.+72     	; 0x1284 <prvCheckTasksWaitingTermination+0x4e>
    123c:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vTaskSuspendAll>
    1240:	c0 91 21 05 	lds	r28, 0x0521	; 0x800521 <xTasksWaitingTermination>
    1244:	0e 94 88 08 	call	0x1110	; 0x1110 <xTaskResumeAll>
    1248:	cc 23       	and	r28, r28
    124a:	e1 f0       	breq	.+56     	; 0x1284 <prvCheckTasksWaitingTermination+0x4e>
    124c:	0f b6       	in	r0, 0x3f	; 63
    124e:	f8 94       	cli
    1250:	0f 92       	push	r0
    1252:	e0 91 26 05 	lds	r30, 0x0526	; 0x800526 <xTasksWaitingTermination+0x5>
    1256:	f0 91 27 05 	lds	r31, 0x0527	; 0x800527 <xTasksWaitingTermination+0x6>
    125a:	c6 81       	ldd	r28, Z+6	; 0x06
    125c:	d7 81       	ldd	r29, Z+7	; 0x07
    125e:	ce 01       	movw	r24, r28
    1260:	02 96       	adiw	r24, 0x02	; 2
    1262:	0e 94 2b 02 	call	0x456	; 0x456 <uxListRemove>
    1266:	80 91 1f 05 	lds	r24, 0x051F	; 0x80051f <uxCurrentNumberOfTasks>
    126a:	81 50       	subi	r24, 0x01	; 1
    126c:	80 93 1f 05 	sts	0x051F, r24	; 0x80051f <uxCurrentNumberOfTasks>
    1270:	80 91 20 05 	lds	r24, 0x0520	; 0x800520 <uxTasksDeleted>
    1274:	81 50       	subi	r24, 0x01	; 1
    1276:	80 93 20 05 	sts	0x0520, r24	; 0x800520 <uxTasksDeleted>
    127a:	0f 90       	pop	r0
    127c:	0f be       	out	0x3f, r0	; 63
    127e:	ce 01       	movw	r24, r28
    1280:	0e 94 37 06 	call	0xc6e	; 0xc6e <prvDeleteTCB>
    1284:	80 91 20 05 	lds	r24, 0x0520	; 0x800520 <uxTasksDeleted>
    1288:	81 11       	cpse	r24, r1
    128a:	d8 cf       	rjmp	.-80     	; 0x123c <prvCheckTasksWaitingTermination+0x6>
    128c:	df 91       	pop	r29
    128e:	cf 91       	pop	r28
    1290:	08 95       	ret

00001292 <prvIdleTask>:
    1292:	0e 94 1b 09 	call	0x1236	; 0x1236 <prvCheckTasksWaitingTermination>
    1296:	80 91 49 05 	lds	r24, 0x0549	; 0x800549 <pxReadyTasksLists>
    129a:	82 30       	cpi	r24, 0x02	; 2
    129c:	d0 f3       	brcs	.-12     	; 0x1292 <prvIdleTask>
    129e:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vPortYield>
    12a2:	f7 cf       	rjmp	.-18     	; 0x1292 <prvIdleTask>

000012a4 <vTaskSwitchContext>:
    12a4:	80 91 16 05 	lds	r24, 0x0516	; 0x800516 <uxSchedulerSuspended>
    12a8:	88 23       	and	r24, r24
    12aa:	21 f0       	breq	.+8      	; 0x12b4 <vTaskSwitchContext+0x10>
    12ac:	81 e0       	ldi	r24, 0x01	; 1
    12ae:	80 93 19 05 	sts	0x0519, r24	; 0x800519 <xYieldPending>
    12b2:	08 95       	ret
    12b4:	10 92 19 05 	sts	0x0519, r1	; 0x800519 <xYieldPending>
    12b8:	05 c0       	rjmp	.+10     	; 0x12c4 <vTaskSwitchContext+0x20>
    12ba:	80 91 1c 05 	lds	r24, 0x051C	; 0x80051c <uxTopReadyPriority>
    12be:	81 50       	subi	r24, 0x01	; 1
    12c0:	80 93 1c 05 	sts	0x051C, r24	; 0x80051c <uxTopReadyPriority>
    12c4:	80 91 1c 05 	lds	r24, 0x051C	; 0x80051c <uxTopReadyPriority>
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	fc 01       	movw	r30, r24
    12cc:	ee 0f       	add	r30, r30
    12ce:	ff 1f       	adc	r31, r31
    12d0:	ee 0f       	add	r30, r30
    12d2:	ff 1f       	adc	r31, r31
    12d4:	ee 0f       	add	r30, r30
    12d6:	ff 1f       	adc	r31, r31
    12d8:	8e 0f       	add	r24, r30
    12da:	9f 1f       	adc	r25, r31
    12dc:	fc 01       	movw	r30, r24
    12de:	e7 5b       	subi	r30, 0xB7	; 183
    12e0:	fa 4f       	sbci	r31, 0xFA	; 250
    12e2:	80 81       	ld	r24, Z
    12e4:	88 23       	and	r24, r24
    12e6:	49 f3       	breq	.-46     	; 0x12ba <vTaskSwitchContext+0x16>
    12e8:	80 91 1c 05 	lds	r24, 0x051C	; 0x80051c <uxTopReadyPriority>
    12ec:	90 e0       	ldi	r25, 0x00	; 0
    12ee:	9c 01       	movw	r18, r24
    12f0:	22 0f       	add	r18, r18
    12f2:	33 1f       	adc	r19, r19
    12f4:	22 0f       	add	r18, r18
    12f6:	33 1f       	adc	r19, r19
    12f8:	22 0f       	add	r18, r18
    12fa:	33 1f       	adc	r19, r19
    12fc:	28 0f       	add	r18, r24
    12fe:	39 1f       	adc	r19, r25
    1300:	d9 01       	movw	r26, r18
    1302:	a7 5b       	subi	r26, 0xB7	; 183
    1304:	ba 4f       	sbci	r27, 0xFA	; 250
    1306:	11 96       	adiw	r26, 0x01	; 1
    1308:	ed 91       	ld	r30, X+
    130a:	fc 91       	ld	r31, X
    130c:	12 97       	sbiw	r26, 0x02	; 2
    130e:	02 80       	ldd	r0, Z+2	; 0x02
    1310:	f3 81       	ldd	r31, Z+3	; 0x03
    1312:	e0 2d       	mov	r30, r0
    1314:	12 96       	adiw	r26, 0x02	; 2
    1316:	fc 93       	st	X, r31
    1318:	ee 93       	st	-X, r30
    131a:	11 97       	sbiw	r26, 0x01	; 1
    131c:	24 5b       	subi	r18, 0xB4	; 180
    131e:	3a 4f       	sbci	r19, 0xFA	; 250
    1320:	e2 17       	cp	r30, r18
    1322:	f3 07       	cpc	r31, r19
    1324:	29 f4       	brne	.+10     	; 0x1330 <vTaskSwitchContext+0x8c>
    1326:	22 81       	ldd	r18, Z+2	; 0x02
    1328:	33 81       	ldd	r19, Z+3	; 0x03
    132a:	fd 01       	movw	r30, r26
    132c:	32 83       	std	Z+2, r19	; 0x02
    132e:	21 83       	std	Z+1, r18	; 0x01
    1330:	fc 01       	movw	r30, r24
    1332:	ee 0f       	add	r30, r30
    1334:	ff 1f       	adc	r31, r31
    1336:	ee 0f       	add	r30, r30
    1338:	ff 1f       	adc	r31, r31
    133a:	ee 0f       	add	r30, r30
    133c:	ff 1f       	adc	r31, r31
    133e:	8e 0f       	add	r24, r30
    1340:	9f 1f       	adc	r25, r31
    1342:	fc 01       	movw	r30, r24
    1344:	e7 5b       	subi	r30, 0xB7	; 183
    1346:	fa 4f       	sbci	r31, 0xFA	; 250
    1348:	01 80       	ldd	r0, Z+1	; 0x01
    134a:	f2 81       	ldd	r31, Z+2	; 0x02
    134c:	e0 2d       	mov	r30, r0
    134e:	86 81       	ldd	r24, Z+6	; 0x06
    1350:	97 81       	ldd	r25, Z+7	; 0x07
    1352:	90 93 6e 05 	sts	0x056E, r25	; 0x80056e <pxCurrentTCB+0x1>
    1356:	80 93 6d 05 	sts	0x056D, r24	; 0x80056d <pxCurrentTCB>
    135a:	08 95       	ret

0000135c <vTaskPlaceOnEventList>:
    135c:	cf 93       	push	r28
    135e:	df 93       	push	r29
    1360:	eb 01       	movw	r28, r22
    1362:	60 91 6d 05 	lds	r22, 0x056D	; 0x80056d <pxCurrentTCB>
    1366:	70 91 6e 05 	lds	r23, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
    136a:	64 5f       	subi	r22, 0xF4	; 244
    136c:	7f 4f       	sbci	r23, 0xFF	; 255
    136e:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <vListInsert>
    1372:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <pxCurrentTCB>
    1376:	90 91 6e 05 	lds	r25, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
    137a:	02 96       	adiw	r24, 0x02	; 2
    137c:	0e 94 2b 02 	call	0x456	; 0x456 <uxListRemove>
    1380:	80 91 1d 05 	lds	r24, 0x051D	; 0x80051d <xTickCount>
    1384:	90 91 1e 05 	lds	r25, 0x051E	; 0x80051e <xTickCount+0x1>
    1388:	8c 0f       	add	r24, r28
    138a:	9d 1f       	adc	r25, r29
    138c:	0e 94 ac 06 	call	0xd58	; 0xd58 <prvAddCurrentTaskToDelayedList>
    1390:	df 91       	pop	r29
    1392:	cf 91       	pop	r28
    1394:	08 95       	ret

00001396 <xTaskRemoveFromEventList>:
    1396:	0f 93       	push	r16
    1398:	1f 93       	push	r17
    139a:	cf 93       	push	r28
    139c:	df 93       	push	r29
    139e:	dc 01       	movw	r26, r24
    13a0:	15 96       	adiw	r26, 0x05	; 5
    13a2:	ed 91       	ld	r30, X+
    13a4:	fc 91       	ld	r31, X
    13a6:	16 97       	sbiw	r26, 0x06	; 6
    13a8:	c6 81       	ldd	r28, Z+6	; 0x06
    13aa:	d7 81       	ldd	r29, Z+7	; 0x07
    13ac:	8e 01       	movw	r16, r28
    13ae:	04 5f       	subi	r16, 0xF4	; 244
    13b0:	1f 4f       	sbci	r17, 0xFF	; 255
    13b2:	c8 01       	movw	r24, r16
    13b4:	0e 94 2b 02 	call	0x456	; 0x456 <uxListRemove>
    13b8:	80 91 16 05 	lds	r24, 0x0516	; 0x800516 <uxSchedulerSuspended>
    13bc:	81 11       	cpse	r24, r1
    13be:	1c c0       	rjmp	.+56     	; 0x13f8 <xTaskRemoveFromEventList+0x62>
    13c0:	0a 50       	subi	r16, 0x0A	; 10
    13c2:	11 09       	sbc	r17, r1
    13c4:	c8 01       	movw	r24, r16
    13c6:	0e 94 2b 02 	call	0x456	; 0x456 <uxListRemove>
    13ca:	8e 89       	ldd	r24, Y+22	; 0x16
    13cc:	90 91 1c 05 	lds	r25, 0x051C	; 0x80051c <uxTopReadyPriority>
    13d0:	98 17       	cp	r25, r24
    13d2:	10 f4       	brcc	.+4      	; 0x13d8 <xTaskRemoveFromEventList+0x42>
    13d4:	80 93 1c 05 	sts	0x051C, r24	; 0x80051c <uxTopReadyPriority>
    13d8:	90 e0       	ldi	r25, 0x00	; 0
    13da:	9c 01       	movw	r18, r24
    13dc:	22 0f       	add	r18, r18
    13de:	33 1f       	adc	r19, r19
    13e0:	22 0f       	add	r18, r18
    13e2:	33 1f       	adc	r19, r19
    13e4:	22 0f       	add	r18, r18
    13e6:	33 1f       	adc	r19, r19
    13e8:	82 0f       	add	r24, r18
    13ea:	93 1f       	adc	r25, r19
    13ec:	b8 01       	movw	r22, r16
    13ee:	87 5b       	subi	r24, 0xB7	; 183
    13f0:	9a 4f       	sbci	r25, 0xFA	; 250
    13f2:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vListInsertEnd>
    13f6:	05 c0       	rjmp	.+10     	; 0x1402 <xTaskRemoveFromEventList+0x6c>
    13f8:	b8 01       	movw	r22, r16
    13fa:	8a e2       	ldi	r24, 0x2A	; 42
    13fc:	95 e0       	ldi	r25, 0x05	; 5
    13fe:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vListInsertEnd>
    1402:	9e 89       	ldd	r25, Y+22	; 0x16
    1404:	e0 91 6d 05 	lds	r30, 0x056D	; 0x80056d <pxCurrentTCB>
    1408:	f0 91 6e 05 	lds	r31, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
    140c:	86 89       	ldd	r24, Z+22	; 0x16
    140e:	89 17       	cp	r24, r25
    1410:	20 f4       	brcc	.+8      	; 0x141a <xTaskRemoveFromEventList+0x84>
    1412:	81 e0       	ldi	r24, 0x01	; 1
    1414:	80 93 19 05 	sts	0x0519, r24	; 0x800519 <xYieldPending>
    1418:	01 c0       	rjmp	.+2      	; 0x141c <xTaskRemoveFromEventList+0x86>
    141a:	80 e0       	ldi	r24, 0x00	; 0
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	1f 91       	pop	r17
    1422:	0f 91       	pop	r16
    1424:	08 95       	ret

00001426 <vTaskSetTimeOutState>:
    1426:	20 91 18 05 	lds	r18, 0x0518	; 0x800518 <xNumOfOverflows>
    142a:	fc 01       	movw	r30, r24
    142c:	20 83       	st	Z, r18
    142e:	20 91 1d 05 	lds	r18, 0x051D	; 0x80051d <xTickCount>
    1432:	30 91 1e 05 	lds	r19, 0x051E	; 0x80051e <xTickCount+0x1>
    1436:	32 83       	std	Z+2, r19	; 0x02
    1438:	21 83       	std	Z+1, r18	; 0x01
    143a:	08 95       	ret

0000143c <xTaskCheckForTimeOut>:
    143c:	cf 93       	push	r28
    143e:	df 93       	push	r29
    1440:	fc 01       	movw	r30, r24
    1442:	0f b6       	in	r0, 0x3f	; 63
    1444:	f8 94       	cli
    1446:	0f 92       	push	r0
    1448:	40 91 1d 05 	lds	r20, 0x051D	; 0x80051d <xTickCount>
    144c:	50 91 1e 05 	lds	r21, 0x051E	; 0x80051e <xTickCount+0x1>
    1450:	90 81       	ld	r25, Z
    1452:	80 91 18 05 	lds	r24, 0x0518	; 0x800518 <xNumOfOverflows>
    1456:	98 17       	cp	r25, r24
    1458:	29 f0       	breq	.+10     	; 0x1464 <xTaskCheckForTimeOut+0x28>
    145a:	81 81       	ldd	r24, Z+1	; 0x01
    145c:	92 81       	ldd	r25, Z+2	; 0x02
    145e:	48 17       	cp	r20, r24
    1460:	59 07       	cpc	r21, r25
    1462:	b0 f4       	brcc	.+44     	; 0x1490 <xTaskCheckForTimeOut+0x54>
    1464:	21 81       	ldd	r18, Z+1	; 0x01
    1466:	32 81       	ldd	r19, Z+2	; 0x02
    1468:	ca 01       	movw	r24, r20
    146a:	82 1b       	sub	r24, r18
    146c:	93 0b       	sbc	r25, r19
    146e:	eb 01       	movw	r28, r22
    1470:	a8 81       	ld	r26, Y
    1472:	b9 81       	ldd	r27, Y+1	; 0x01
    1474:	8a 17       	cp	r24, r26
    1476:	9b 07       	cpc	r25, r27
    1478:	68 f4       	brcc	.+26     	; 0x1494 <xTaskCheckForTimeOut+0x58>
    147a:	cf 01       	movw	r24, r30
    147c:	24 1b       	sub	r18, r20
    147e:	35 0b       	sbc	r19, r21
    1480:	2a 0f       	add	r18, r26
    1482:	3b 1f       	adc	r19, r27
    1484:	39 83       	std	Y+1, r19	; 0x01
    1486:	28 83       	st	Y, r18
    1488:	0e 94 13 0a 	call	0x1426	; 0x1426 <vTaskSetTimeOutState>
    148c:	80 e0       	ldi	r24, 0x00	; 0
    148e:	03 c0       	rjmp	.+6      	; 0x1496 <xTaskCheckForTimeOut+0x5a>
    1490:	81 e0       	ldi	r24, 0x01	; 1
    1492:	01 c0       	rjmp	.+2      	; 0x1496 <xTaskCheckForTimeOut+0x5a>
    1494:	81 e0       	ldi	r24, 0x01	; 1
    1496:	0f 90       	pop	r0
    1498:	0f be       	out	0x3f, r0	; 63
    149a:	df 91       	pop	r29
    149c:	cf 91       	pop	r28
    149e:	08 95       	ret

000014a0 <vTaskMissedYield>:
    14a0:	81 e0       	ldi	r24, 0x01	; 1
    14a2:	80 93 19 05 	sts	0x0519, r24	; 0x800519 <xYieldPending>
    14a6:	08 95       	ret

000014a8 <vTaskPriorityInherit>:
    14a8:	0f 93       	push	r16
    14aa:	1f 93       	push	r17
    14ac:	cf 93       	push	r28
    14ae:	df 93       	push	r29
    14b0:	fc 01       	movw	r30, r24
    14b2:	89 2b       	or	r24, r25
    14b4:	09 f4       	brne	.+2      	; 0x14b8 <vTaskPriorityInherit+0x10>
    14b6:	55 c0       	rjmp	.+170    	; 0x1562 <vTaskPriorityInherit+0xba>
    14b8:	26 89       	ldd	r18, Z+22	; 0x16
    14ba:	a0 91 6d 05 	lds	r26, 0x056D	; 0x80056d <pxCurrentTCB>
    14be:	b0 91 6e 05 	lds	r27, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
    14c2:	56 96       	adiw	r26, 0x16	; 22
    14c4:	8c 91       	ld	r24, X
    14c6:	28 17       	cp	r18, r24
    14c8:	08 f0       	brcs	.+2      	; 0x14cc <vTaskPriorityInherit+0x24>
    14ca:	4b c0       	rjmp	.+150    	; 0x1562 <vTaskPriorityInherit+0xba>
    14cc:	84 85       	ldd	r24, Z+12	; 0x0c
    14ce:	95 85       	ldd	r25, Z+13	; 0x0d
    14d0:	99 23       	and	r25, r25
    14d2:	64 f0       	brlt	.+24     	; 0x14ec <vTaskPriorityInherit+0x44>
    14d4:	a0 91 6d 05 	lds	r26, 0x056D	; 0x80056d <pxCurrentTCB>
    14d8:	b0 91 6e 05 	lds	r27, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
    14dc:	56 96       	adiw	r26, 0x16	; 22
    14de:	3c 91       	ld	r19, X
    14e0:	84 e0       	ldi	r24, 0x04	; 4
    14e2:	90 e0       	ldi	r25, 0x00	; 0
    14e4:	83 1b       	sub	r24, r19
    14e6:	91 09       	sbc	r25, r1
    14e8:	95 87       	std	Z+13, r25	; 0x0d
    14ea:	84 87       	std	Z+12, r24	; 0x0c
    14ec:	82 85       	ldd	r24, Z+10	; 0x0a
    14ee:	93 85       	ldd	r25, Z+11	; 0x0b
    14f0:	30 e0       	ldi	r19, 0x00	; 0
    14f2:	a9 01       	movw	r20, r18
    14f4:	44 0f       	add	r20, r20
    14f6:	55 1f       	adc	r21, r21
    14f8:	44 0f       	add	r20, r20
    14fa:	55 1f       	adc	r21, r21
    14fc:	44 0f       	add	r20, r20
    14fe:	55 1f       	adc	r21, r21
    1500:	24 0f       	add	r18, r20
    1502:	35 1f       	adc	r19, r21
    1504:	27 5b       	subi	r18, 0xB7	; 183
    1506:	3a 4f       	sbci	r19, 0xFA	; 250
    1508:	82 17       	cp	r24, r18
    150a:	93 07       	cpc	r25, r19
    150c:	19 f5       	brne	.+70     	; 0x1554 <vTaskPriorityInherit+0xac>
    150e:	8f 01       	movw	r16, r30
    1510:	ef 01       	movw	r28, r30
    1512:	22 96       	adiw	r28, 0x02	; 2
    1514:	ce 01       	movw	r24, r28
    1516:	0e 94 2b 02 	call	0x456	; 0x456 <uxListRemove>
    151a:	e0 91 6d 05 	lds	r30, 0x056D	; 0x80056d <pxCurrentTCB>
    151e:	f0 91 6e 05 	lds	r31, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
    1522:	86 89       	ldd	r24, Z+22	; 0x16
    1524:	f8 01       	movw	r30, r16
    1526:	86 8b       	std	Z+22, r24	; 0x16
    1528:	90 91 1c 05 	lds	r25, 0x051C	; 0x80051c <uxTopReadyPriority>
    152c:	98 17       	cp	r25, r24
    152e:	10 f4       	brcc	.+4      	; 0x1534 <vTaskPriorityInherit+0x8c>
    1530:	80 93 1c 05 	sts	0x051C, r24	; 0x80051c <uxTopReadyPriority>
    1534:	90 e0       	ldi	r25, 0x00	; 0
    1536:	9c 01       	movw	r18, r24
    1538:	22 0f       	add	r18, r18
    153a:	33 1f       	adc	r19, r19
    153c:	22 0f       	add	r18, r18
    153e:	33 1f       	adc	r19, r19
    1540:	22 0f       	add	r18, r18
    1542:	33 1f       	adc	r19, r19
    1544:	82 0f       	add	r24, r18
    1546:	93 1f       	adc	r25, r19
    1548:	be 01       	movw	r22, r28
    154a:	87 5b       	subi	r24, 0xB7	; 183
    154c:	9a 4f       	sbci	r25, 0xFA	; 250
    154e:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vListInsertEnd>
    1552:	07 c0       	rjmp	.+14     	; 0x1562 <vTaskPriorityInherit+0xba>
    1554:	a0 91 6d 05 	lds	r26, 0x056D	; 0x80056d <pxCurrentTCB>
    1558:	b0 91 6e 05 	lds	r27, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
    155c:	56 96       	adiw	r26, 0x16	; 22
    155e:	8c 91       	ld	r24, X
    1560:	86 8b       	std	Z+22, r24	; 0x16
    1562:	df 91       	pop	r29
    1564:	cf 91       	pop	r28
    1566:	1f 91       	pop	r17
    1568:	0f 91       	pop	r16
    156a:	08 95       	ret

0000156c <xTaskPriorityDisinherit>:
    156c:	0f 93       	push	r16
    156e:	1f 93       	push	r17
    1570:	cf 93       	push	r28
    1572:	df 93       	push	r29
    1574:	fc 01       	movw	r30, r24
    1576:	89 2b       	or	r24, r25
    1578:	79 f1       	breq	.+94     	; 0x15d8 <xTaskPriorityDisinherit+0x6c>
    157a:	86 a5       	ldd	r24, Z+46	; 0x2e
    157c:	81 50       	subi	r24, 0x01	; 1
    157e:	86 a7       	std	Z+46, r24	; 0x2e
    1580:	26 89       	ldd	r18, Z+22	; 0x16
    1582:	95 a5       	ldd	r25, Z+45	; 0x2d
    1584:	29 17       	cp	r18, r25
    1586:	51 f1       	breq	.+84     	; 0x15dc <xTaskPriorityDisinherit+0x70>
    1588:	81 11       	cpse	r24, r1
    158a:	2a c0       	rjmp	.+84     	; 0x15e0 <xTaskPriorityDisinherit+0x74>
    158c:	ef 01       	movw	r28, r30
    158e:	8f 01       	movw	r16, r30
    1590:	0e 5f       	subi	r16, 0xFE	; 254
    1592:	1f 4f       	sbci	r17, 0xFF	; 255
    1594:	c8 01       	movw	r24, r16
    1596:	0e 94 2b 02 	call	0x456	; 0x456 <uxListRemove>
    159a:	8d a5       	ldd	r24, Y+45	; 0x2d
    159c:	8e 8b       	std	Y+22, r24	; 0x16
    159e:	24 e0       	ldi	r18, 0x04	; 4
    15a0:	30 e0       	ldi	r19, 0x00	; 0
    15a2:	28 1b       	sub	r18, r24
    15a4:	31 09       	sbc	r19, r1
    15a6:	3d 87       	std	Y+13, r19	; 0x0d
    15a8:	2c 87       	std	Y+12, r18	; 0x0c
    15aa:	90 91 1c 05 	lds	r25, 0x051C	; 0x80051c <uxTopReadyPriority>
    15ae:	98 17       	cp	r25, r24
    15b0:	10 f4       	brcc	.+4      	; 0x15b6 <xTaskPriorityDisinherit+0x4a>
    15b2:	80 93 1c 05 	sts	0x051C, r24	; 0x80051c <uxTopReadyPriority>
    15b6:	90 e0       	ldi	r25, 0x00	; 0
    15b8:	9c 01       	movw	r18, r24
    15ba:	22 0f       	add	r18, r18
    15bc:	33 1f       	adc	r19, r19
    15be:	22 0f       	add	r18, r18
    15c0:	33 1f       	adc	r19, r19
    15c2:	22 0f       	add	r18, r18
    15c4:	33 1f       	adc	r19, r19
    15c6:	82 0f       	add	r24, r18
    15c8:	93 1f       	adc	r25, r19
    15ca:	b8 01       	movw	r22, r16
    15cc:	87 5b       	subi	r24, 0xB7	; 183
    15ce:	9a 4f       	sbci	r25, 0xFA	; 250
    15d0:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vListInsertEnd>
    15d4:	81 e0       	ldi	r24, 0x01	; 1
    15d6:	05 c0       	rjmp	.+10     	; 0x15e2 <xTaskPriorityDisinherit+0x76>
    15d8:	80 e0       	ldi	r24, 0x00	; 0
    15da:	03 c0       	rjmp	.+6      	; 0x15e2 <xTaskPriorityDisinherit+0x76>
    15dc:	80 e0       	ldi	r24, 0x00	; 0
    15de:	01 c0       	rjmp	.+2      	; 0x15e2 <xTaskPriorityDisinherit+0x76>
    15e0:	80 e0       	ldi	r24, 0x00	; 0
    15e2:	df 91       	pop	r29
    15e4:	cf 91       	pop	r28
    15e6:	1f 91       	pop	r17
    15e8:	0f 91       	pop	r16
    15ea:	08 95       	ret

000015ec <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    15ec:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <pxCurrentTCB>
    15f0:	90 91 6e 05 	lds	r25, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
    15f4:	89 2b       	or	r24, r25
    15f6:	39 f0       	breq	.+14     	; 0x1606 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    15f8:	e0 91 6d 05 	lds	r30, 0x056D	; 0x80056d <pxCurrentTCB>
    15fc:	f0 91 6e 05 	lds	r31, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
    1600:	86 a5       	ldd	r24, Z+46	; 0x2e
    1602:	8f 5f       	subi	r24, 0xFF	; 255
    1604:	86 a7       	std	Z+46, r24	; 0x2e
		}

		return pxCurrentTCB;
    1606:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <pxCurrentTCB>
    160a:	90 91 6e 05 	lds	r25, 0x056E	; 0x80056e <pxCurrentTCB+0x1>
	}
    160e:	08 95       	ret

00001610 <T_T1>:
	return 0;
}
void T_T1(void* pvParam){
	u8 key = 0; 
	while (1){
		if (xSemaphoreTake(mResourceAvailability,1000)){
    1610:	20 e0       	ldi	r18, 0x00	; 0
    1612:	48 ee       	ldi	r20, 0xE8	; 232
    1614:	53 e0       	ldi	r21, 0x03	; 3
    1616:	60 e0       	ldi	r22, 0x00	; 0
    1618:	70 e0       	ldi	r23, 0x00	; 0
    161a:	80 91 6f 05 	lds	r24, 0x056F	; 0x80056f <mResourceAvailability>
    161e:	90 91 70 05 	lds	r25, 0x0570	; 0x800570 <mResourceAvailability+0x1>
    1622:	0e 94 36 05 	call	0xa6c	; 0xa6c <xQueueGenericReceive>
    1626:	88 23       	and	r24, r24
    1628:	99 f3       	breq	.-26     	; 0x1610 <T_T1>
			Uart_SendStr("AT+SMS\r\n");
    162a:	87 e6       	ldi	r24, 0x67	; 103
    162c:	90 e0       	ldi	r25, 0x00	; 0
    162e:	0e 94 72 01 	call	0x2e4	; 0x2e4 <Uart_SendStr>
			Uart_SendStr("AT+SMS\r\n");
    1632:	87 e6       	ldi	r24, 0x67	; 103
    1634:	90 e0       	ldi	r25, 0x00	; 0
    1636:	0e 94 72 01 	call	0x2e4	; 0x2e4 <Uart_SendStr>
			xSemaphoreGive(mResourceAvailability);
    163a:	20 e0       	ldi	r18, 0x00	; 0
    163c:	40 e0       	ldi	r20, 0x00	; 0
    163e:	50 e0       	ldi	r21, 0x00	; 0
    1640:	60 e0       	ldi	r22, 0x00	; 0
    1642:	70 e0       	ldi	r23, 0x00	; 0
    1644:	80 91 6f 05 	lds	r24, 0x056F	; 0x80056f <mResourceAvailability>
    1648:	90 91 70 05 	lds	r25, 0x0570	; 0x800570 <mResourceAvailability+0x1>
    164c:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xQueueGenericSend>
    1650:	df cf       	rjmp	.-66     	; 0x1610 <T_T1>

00001652 <T_T2>:
		}
	}
}
void T_T2(void* pvParam){
	while (1){ 
		if (xSemaphoreTake(mResourceAvailability,1000)){
    1652:	20 e0       	ldi	r18, 0x00	; 0
    1654:	48 ee       	ldi	r20, 0xE8	; 232
    1656:	53 e0       	ldi	r21, 0x03	; 3
    1658:	60 e0       	ldi	r22, 0x00	; 0
    165a:	70 e0       	ldi	r23, 0x00	; 0
    165c:	80 91 6f 05 	lds	r24, 0x056F	; 0x80056f <mResourceAvailability>
    1660:	90 91 70 05 	lds	r25, 0x0570	; 0x800570 <mResourceAvailability+0x1>
    1664:	0e 94 36 05 	call	0xa6c	; 0xa6c <xQueueGenericReceive>
    1668:	88 23       	and	r24, r24
    166a:	99 f0       	breq	.+38     	; 0x1692 <T_T2+0x40>
			Uart_SendStr("AT+Server1\r\n");
    166c:	80 e7       	ldi	r24, 0x70	; 112
    166e:	90 e0       	ldi	r25, 0x00	; 0
    1670:	0e 94 72 01 	call	0x2e4	; 0x2e4 <Uart_SendStr>
			Uart_SendStr("AT+Server2\r\n");	
    1674:	8d e7       	ldi	r24, 0x7D	; 125
    1676:	90 e0       	ldi	r25, 0x00	; 0
    1678:	0e 94 72 01 	call	0x2e4	; 0x2e4 <Uart_SendStr>
			xSemaphoreGive(mResourceAvailability); 
    167c:	20 e0       	ldi	r18, 0x00	; 0
    167e:	40 e0       	ldi	r20, 0x00	; 0
    1680:	50 e0       	ldi	r21, 0x00	; 0
    1682:	60 e0       	ldi	r22, 0x00	; 0
    1684:	70 e0       	ldi	r23, 0x00	; 0
    1686:	80 91 6f 05 	lds	r24, 0x056F	; 0x80056f <mResourceAvailability>
    168a:	90 91 70 05 	lds	r25, 0x0570	; 0x800570 <mResourceAvailability+0x1>
    168e:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xQueueGenericSend>
		}
		vTaskDelay(5);
    1692:	85 e0       	ldi	r24, 0x05	; 5
    1694:	90 e0       	ldi	r25, 0x00	; 0
    1696:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <vTaskDelay>
	}
    169a:	db cf       	rjmp	.-74     	; 0x1652 <T_T2>

0000169c <system_init>:
#include "queue.h"
#include "semphr.h"
#include "event_groups.h"

void system_init(void){
	Leds_AllInit();
    169c:	0e 94 58 00 	call	0xb0	; 0xb0 <Leds_AllInit>
	LCD_Init();
    16a0:	0e 94 05 01 	call	0x20a	; 0x20a <LCD_Init>
	LCD_DispStrXY(1,1,(u8*)"Res App: ");
    16a4:	4a e8       	ldi	r20, 0x8A	; 138
    16a6:	50 e0       	ldi	r21, 0x00	; 0
    16a8:	61 e0       	ldi	r22, 0x01	; 1
    16aa:	81 e0       	ldi	r24, 0x01	; 1
    16ac:	0e 94 3e 01 	call	0x27c	; 0x27c <LCD_DispStrXY>
	Key_Init();
    16b0:	0e 94 5e 00 	call	0xbc	; 0xbc <Key_Init>
	Uart_Init(9600);
    16b4:	60 e8       	ldi	r22, 0x80	; 128
    16b6:	75 e2       	ldi	r23, 0x25	; 37
    16b8:	80 e0       	ldi	r24, 0x00	; 0
    16ba:	90 e0       	ldi	r25, 0x00	; 0
    16bc:	0e 94 49 01 	call	0x292	; 0x292 <Uart_Init>
	Uart_SendStr("Res App: ");
    16c0:	8a e8       	ldi	r24, 0x8A	; 138
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    16c4:	0e 94 72 01 	call	0x2e4	; 0x2e4 <Uart_SendStr>
    16c8:	08 95       	ret

000016ca <main>:
void T_T2(void* pvParam);
void T_T3(void* pvParam);

xSemaphoreHandle mResourceAvailability = NULL;
int main(void)
{
    16ca:	af 92       	push	r10
    16cc:	bf 92       	push	r11
    16ce:	cf 92       	push	r12
    16d0:	df 92       	push	r13
    16d2:	ef 92       	push	r14
    16d4:	ff 92       	push	r15
    16d6:	0f 93       	push	r16
	system_init();
    16d8:	0e 94 4e 0b 	call	0x169c	; 0x169c <system_init>
	mResourceAvailability = xSemaphoreCreateMutex();
    16dc:	81 e0       	ldi	r24, 0x01	; 1
    16de:	0e 94 0a 05 	call	0xa14	; 0xa14 <xQueueCreateMutex>
    16e2:	90 93 70 05 	sts	0x0570, r25	; 0x800570 <mResourceAvailability+0x1>
    16e6:	80 93 6f 05 	sts	0x056F, r24	; 0x80056f <mResourceAvailability>
	xTaskCreate(T_T1, NULL, 100, NULL, 1, NULL);
    16ea:	a1 2c       	mov	r10, r1
    16ec:	b1 2c       	mov	r11, r1
    16ee:	c1 2c       	mov	r12, r1
    16f0:	d1 2c       	mov	r13, r1
    16f2:	e1 2c       	mov	r14, r1
    16f4:	f1 2c       	mov	r15, r1
    16f6:	01 e0       	ldi	r16, 0x01	; 1
    16f8:	20 e0       	ldi	r18, 0x00	; 0
    16fa:	30 e0       	ldi	r19, 0x00	; 0
    16fc:	44 e6       	ldi	r20, 0x64	; 100
    16fe:	50 e0       	ldi	r21, 0x00	; 0
    1700:	60 e0       	ldi	r22, 0x00	; 0
    1702:	70 e0       	ldi	r23, 0x00	; 0
    1704:	88 e0       	ldi	r24, 0x08	; 8
    1706:	9b e0       	ldi	r25, 0x0B	; 11
    1708:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <xTaskGenericCreate>
	xTaskCreate(T_T2, NULL, 100, NULL, 2, NULL);
    170c:	02 e0       	ldi	r16, 0x02	; 2
    170e:	20 e0       	ldi	r18, 0x00	; 0
    1710:	30 e0       	ldi	r19, 0x00	; 0
    1712:	44 e6       	ldi	r20, 0x64	; 100
    1714:	50 e0       	ldi	r21, 0x00	; 0
    1716:	60 e0       	ldi	r22, 0x00	; 0
    1718:	70 e0       	ldi	r23, 0x00	; 0
    171a:	89 e2       	ldi	r24, 0x29	; 41
    171c:	9b e0       	ldi	r25, 0x0B	; 11
    171e:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <xTaskGenericCreate>
	/* xTaskCreate(T_T3, NULL, 100, NULL, 3, NULL); */ 
	vTaskStartScheduler();
    1722:	0e 94 9b 07 	call	0xf36	; 0xf36 <vTaskStartScheduler>
	return 0;
}
    1726:	80 e0       	ldi	r24, 0x00	; 0
    1728:	90 e0       	ldi	r25, 0x00	; 0
    172a:	0f 91       	pop	r16
    172c:	ff 90       	pop	r15
    172e:	ef 90       	pop	r14
    1730:	df 90       	pop	r13
    1732:	cf 90       	pop	r12
    1734:	bf 90       	pop	r11
    1736:	af 90       	pop	r10
    1738:	08 95       	ret

0000173a <__udivmodsi4>:
    173a:	a1 e2       	ldi	r26, 0x21	; 33
    173c:	1a 2e       	mov	r1, r26
    173e:	aa 1b       	sub	r26, r26
    1740:	bb 1b       	sub	r27, r27
    1742:	fd 01       	movw	r30, r26
    1744:	0d c0       	rjmp	.+26     	; 0x1760 <__udivmodsi4_ep>

00001746 <__udivmodsi4_loop>:
    1746:	aa 1f       	adc	r26, r26
    1748:	bb 1f       	adc	r27, r27
    174a:	ee 1f       	adc	r30, r30
    174c:	ff 1f       	adc	r31, r31
    174e:	a2 17       	cp	r26, r18
    1750:	b3 07       	cpc	r27, r19
    1752:	e4 07       	cpc	r30, r20
    1754:	f5 07       	cpc	r31, r21
    1756:	20 f0       	brcs	.+8      	; 0x1760 <__udivmodsi4_ep>
    1758:	a2 1b       	sub	r26, r18
    175a:	b3 0b       	sbc	r27, r19
    175c:	e4 0b       	sbc	r30, r20
    175e:	f5 0b       	sbc	r31, r21

00001760 <__udivmodsi4_ep>:
    1760:	66 1f       	adc	r22, r22
    1762:	77 1f       	adc	r23, r23
    1764:	88 1f       	adc	r24, r24
    1766:	99 1f       	adc	r25, r25
    1768:	1a 94       	dec	r1
    176a:	69 f7       	brne	.-38     	; 0x1746 <__udivmodsi4_loop>
    176c:	60 95       	com	r22
    176e:	70 95       	com	r23
    1770:	80 95       	com	r24
    1772:	90 95       	com	r25
    1774:	9b 01       	movw	r18, r22
    1776:	ac 01       	movw	r20, r24
    1778:	bd 01       	movw	r22, r26
    177a:	cf 01       	movw	r24, r30
    177c:	08 95       	ret

0000177e <memcpy>:
    177e:	fb 01       	movw	r30, r22
    1780:	dc 01       	movw	r26, r24
    1782:	02 c0       	rjmp	.+4      	; 0x1788 <memcpy+0xa>
    1784:	01 90       	ld	r0, Z+
    1786:	0d 92       	st	X+, r0
    1788:	41 50       	subi	r20, 0x01	; 1
    178a:	50 40       	sbci	r21, 0x00	; 0
    178c:	d8 f7       	brcc	.-10     	; 0x1784 <memcpy+0x6>
    178e:	08 95       	ret

00001790 <_exit>:
    1790:	f8 94       	cli

00001792 <__stop_program>:
    1792:	ff cf       	rjmp	.-2      	; 0x1792 <__stop_program>
